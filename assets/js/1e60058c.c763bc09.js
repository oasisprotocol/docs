"use strict";(globalThis.webpackChunkdocs_oasis_io=globalThis.webpackChunkdocs_oasis_io||[]).push([[713],{5146:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/oasis-core-consensus-cometbft-604c57fd4ffe73d71eba188e6cff9a3f.svg"},28453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>c});var t=n(96540);const o={},i=t.createContext(o);function r(e){const s=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(i.Provider,{value:s},e.children)}},90032:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"core/consensus/README","title":"Consensus Layer","description":"Oasis Core is designed around the principle of modularity. The consensus layer","source":"@site/docs/core/consensus/README.md","sourceDirName":"core/consensus","slug":"/core/consensus/","permalink":"/core/consensus/","draft":false,"unlisted":false,"editUrl":"https://github.com/oasisprotocol/oasis-core/edit/stable/24.2.x/docs/consensus/README.md","tags":[],"version":"current","lastUpdatedAt":1768997119000,"frontMatter":{"sidebar_custom_props":{}},"sidebar":"oasisCore","previous":{"title":"High-Level Components","permalink":"/core/high-level-components"},"next":{"title":"Transactions","permalink":"/core/consensus/transactions"}}');var o=n(74848),i=n(28453);const r={sidebar_custom_props:{tags:void 0}},c="Consensus Layer",a={},l=[{value:"CometBFT",id:"cometbft",level:2},{value:"ABCI Application Multiplexer",id:"abci-application-multiplexer",level:3},{value:"State Storage",id:"state-storage",level:3},{value:"Service Implementations",id:"service-implementations",level:3},{value:"Queries",id:"queries",level:4},{value:"Transactions",id:"transactions",level:4}];function h(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.header,{children:(0,o.jsx)(s.h1,{id:"consensus-layer",children:"Consensus Layer"})}),"\n",(0,o.jsxs)(s.p,{children:["Oasis Core is designed around the principle of modularity. The ",(0,o.jsx)(s.em,{children:"consensus layer"}),"\nis an interface that provides a number of important services to other parts of\nOasis Core. This allows, in theory, for the consensus backend to be changed. The\ndifferent backends live in ",(0,o.jsx)(s.a,{href:"https://github.com/oasisprotocol/oasis-core/tree/master/go/consensus",children:(0,o.jsx)(s.code,{children:"go/consensus"})}),", with the general interfaces in\n",(0,o.jsx)(s.a,{href:"https://github.com/oasisprotocol/oasis-core/tree/master/go/consensus/api",children:(0,o.jsx)(s.code,{children:"go/consensus/api"})}),". The general rule is that anything outside of a specific\nconsensus backend package should be consensus backend agnostic."]}),"\n",(0,o.jsxs)(s.p,{children:["For more details about the actual API that the consensus backends must provide\nsee the ",(0,o.jsx)(s.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/consensus/api?tab=doc",children:"consensus backend API documentation"}),"."]}),"\n",(0,o.jsxs)(s.p,{children:["Currently the only supported consensus backend is ",(0,o.jsx)(s.a,{href:"https://cometbft.com/",children:"CometBFT"}),", a BFT consensus\nprotocol. For this reason some API surfaces may not be fully consensus backend\nagnostic."]}),"\n",(0,o.jsx)(s.p,{children:"Each consensus backend needs to provide the following services:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.a,{href:"/core/consensus/services/epochtime",children:"Epoch Time"}),", an epoch-based time keeping service."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.a,{href:"/core/consensus/services/beacon",children:"Random Beacon"}),", a source of randomness for other services."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.a,{href:"/core/consensus/services/staking",children:"Staking"}),", operations required to operate a PoS blockchain."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.a,{href:"/core/consensus/services/registry",children:"Registry"}),", an entity/node/runtime public key and metadata registry service."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.a,{href:"/core/consensus/services/scheduler",children:"Committee Scheduler"})," service."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.a,{href:"/core/consensus/services/governance",children:"Governance"})," service."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.a,{href:"/core/consensus/services/roothash",children:"Root Hash"}),", runtime commitment processing and minimal runtime state keeping\nservice."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.a,{href:"/core/consensus/services/keymanager",children:"Key Manager"})," policy state keeping service."]}),"\n"]}),"\n",(0,o.jsxs)(s.p,{children:["Each of the above services provides methods to query its current state. In order\nto mutate the current state, each operation needs to be wrapped into a\n",(0,o.jsx)(s.a,{href:"/core/consensus/transactions",children:"consensus transaction"})," and submitted to the consensus layer for processing."]}),"\n",(0,o.jsxs)(s.p,{children:["Oasis Core defines an interface for each kind of service (in\n",(0,o.jsx)(s.code,{children:"go/<service>/api"}),"), with all concrete service implementations living together\nwith the consensus backend implementation. The service API defines the\ntransaction format for mutating state together with any query methods (both are\nconsensus backend agnostic)."]}),"\n",(0,o.jsx)(s.h2,{id:"cometbft",children:"CometBFT"}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.img,{alt:"CometBFT",src:n(5146).A+""})}),"\n",(0,o.jsxs)(s.p,{children:["The CometBFT consensus backend lives in ",(0,o.jsx)(s.a,{href:"https://github.com/oasisprotocol/oasis-core/tree/master/go/consensus/cometbft",children:(0,o.jsx)(s.code,{children:"go/consensus/cometbft"})}),"."]}),"\n",(0,o.jsxs)(s.p,{children:["For more information about CometBFT itself see\n",(0,o.jsx)(s.a,{href:"https://docs.cometbft.com/",children:"the CometBFT Core developer documentation"}),". This section assumes familiarity\nwith the CometBFT Core concepts and APIs. When used as an Oasis Core consensus\nbackend, CometBFT Core is used as a library and thus lives in the same\nprocess."]}),"\n",(0,o.jsx)(s.p,{children:"The CometBFT consensus backend is split into two major parts:"}),"\n",(0,o.jsxs)(s.ol,{children:["\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:["The first part is the ",(0,o.jsx)(s.strong,{children:"ABCI application"})," that represents the core logic\nthat is replicated by CometBFT Core among the network nodes using the\nCometBFT BFT protocol for consensus."]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:["The second part is the ",(0,o.jsx)(s.strong,{children:"query and transaction submission glue"})," that makes\nit easy to interact with the ABCI application, presenting everything via the\nOasis Core Consensus interface."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(s.h3,{id:"abci-application-multiplexer",children:"ABCI Application Multiplexer"}),"\n",(0,o.jsxs)(s.p,{children:["CometBFT Core consumes consensus layer logic via the ",(0,o.jsx)(s.a,{href:"https://github.com/cometbft/cometbft/blob/master/spec/abci/abci.md",children:"ABCI protocol"}),", which\nassumes a single application. Since we have multiple services that need to be\nprovided by the consensus layer we use an ",(0,o.jsx)(s.em,{children:"ABCI application multiplexer"})," which\nperforms some common functions and dispatches transactions to the appropriate\nservice-specific handler."]}),"\n",(0,o.jsxs)(s.p,{children:["The multiplexer lives in ",(0,o.jsx)(s.a,{href:"https://github.com/oasisprotocol/oasis-core/tree/master/go/consensus/cometbft/abci/mux.go",children:(0,o.jsx)(s.code,{children:"go/consensus/cometbft/abci/mux.go"})})," with the\nmultiplexed applications, generally corresponding to services required by the\n",(0,o.jsx)(s.em,{children:"consensus layer"})," interface living in ",(0,o.jsx)(s.a,{href:"https://github.com/oasisprotocol/oasis-core/tree/master/go/consensus/cometbft/apps",children:(0,o.jsx)(s.code,{children:"go/consensus/cometbft/apps/<app>"})}),"."]}),"\n",(0,o.jsx)(s.h3,{id:"state-storage",children:"State Storage"}),"\n",(0,o.jsxs)(s.p,{children:["All application state for the CometBFT consensus backend is stored using our\n",(0,o.jsx)(s.a,{href:"/core/mkvs",children:"Merklized Key-Value Store"}),"."]}),"\n",(0,o.jsx)(s.h3,{id:"service-implementations",children:"Service Implementations"}),"\n",(0,o.jsxs)(s.p,{children:["Service implementations for the CometBFT consensus backend live in\n",(0,o.jsx)(s.a,{href:"https://github.com/oasisprotocol/oasis-core/tree/master/go/consensus/cometbft",children:(0,o.jsx)(s.code,{children:"go/consensus/cometbft/<service>"})}),". They provide the glue between the\nservices running as part of the ABCI application multiplexer and the Oasis Core\nservice APIs. The interfaces generally provide a read-only view of the consensus\nlayer state at a given height. Internally, these perform queries against the\nABCI application state."]}),"\n",(0,o.jsx)(s.h4,{id:"queries",children:"Queries"}),"\n",(0,o.jsxs)(s.p,{children:["Queries do not use the ",(0,o.jsx)(s.a,{href:"https://github.com/cometbft/cometbft/blob/master/spec/abci/abci.md#query-1",children:"ABCI query functionality"})," as that would incur needless\noverhead for our use case (with CometBFT Core running in the same process).\nInstead, each multiplexed service provides its own ",(0,o.jsx)(s.code,{children:"QueryFactory"})," which can be\nused to query state at a specific block height."]}),"\n",(0,o.jsxs)(s.p,{children:["An example of a ",(0,o.jsx)(s.code,{children:"QueryFactory"})," and the corresponding ",(0,o.jsx)(s.code,{children:"Query"})," interfaces for the\nstaking service are as follows:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-golang",children:"// QueryFactory is the staking query factory interface.\ntype QueryFactory interface {\n    QueryAt(ctx context.Context, height int64) (Query, error)\n}\n\n// Query is the staking query interface.\ntype Query interface {\n    TotalSupply(ctx context.Context) (*quantity.Quantity, error)\n    CommonPool(ctx context.Context) (*quantity.Quantity, error)\n    LastBlockFees(ctx context.Context) (*quantity.Quantity, error)\n\n    // ... further query methods omitted ...\n}\n"})}),"\n",(0,o.jsxs)(s.p,{children:["Implementations of this interface generally directly access the underlying ABCI\nstate storage to answer queries. CometBFT implementations of Oasis Core\nconsensus services generally follow the following pattern (example from the\nstaking service API for querying ",(0,o.jsx)(s.code,{children:"TotalSupply"}),"):"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-golang",children:"func (s *staking) TotalSupply(ctx context.Context, height int64) (*quantity.Quantity, error) {\n    q, err := s.querier.QueryAt(ctx, height)\n    if err != nil {\n        return nil, err\n    }\n\n    return q.TotalSupply(ctx)\n}\n"})}),"\n",(0,o.jsx)(s.h4,{id:"transactions",children:"Transactions"}),"\n",(0,o.jsxs)(s.p,{children:["Each ",(0,o.jsx)(s.a,{href:"/core/consensus/transactions",children:"serialized signed Oasis Core transaction"})," directly corresponds to a\n",(0,o.jsx)(s.a,{href:"https://docs.cometbft.com/v0.38/core/using-cometbft#transactions",children:"CometBFT transaction"}),". Submission is performed by pushing the serialized\ntransaction bytes into the ",(0,o.jsx)(s.a,{href:"https://github.com/cometbft/cometbft/blob/master/spec/abci/abci.md#mempool-connection",children:"mempool"})," where it first undergoes basic checks and\nis then gossiped to the CometBFT P2P network."]}),"\n",(0,o.jsx)(s.p,{children:"Handling of basic checks and transaction execution is performed by the ABCI\napplication multiplexer mentioned above."})]})}function d(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);