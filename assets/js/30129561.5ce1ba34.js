"use strict";(globalThis.webpackChunkdocs_oasis_io=globalThis.webpackChunkdocs_oasis_io||[]).push([[1662],{28453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>a});var n=s(96540);const o={},i=n.createContext(o);function r(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),n.createElement(i.Provider,{value:t},e.children)}},31029:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/oasis-core-runtime-execution-502d059c83dd21c3135c993c339f9240.svg"},89470:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"core/runtime/runtime-host-protocol","title":"Runtime Host Protocol","description":"The Runtime Host Protocol (RHP) is a simple RPC protocol which is used to","source":"@site/docs/core/runtime/runtime-host-protocol.md","sourceDirName":"core/runtime","slug":"/core/runtime/runtime-host-protocol","permalink":"/core/runtime/runtime-host-protocol","draft":false,"unlisted":false,"editUrl":"https://github.com/oasisprotocol/oasis-core/edit/stable/24.2.x/docs/runtime/runtime-host-protocol.md","tags":[],"version":"current","lastUpdatedAt":1757571245000,"frontMatter":{"sidebar_custom_props":{}},"sidebar":"oasisCore","previous":{"title":"Runtime Layer","permalink":"/core/runtime/"},"next":{"title":"Runtime IDs","permalink":"/core/runtime/identifiers"}}');var o=s(74848),i=s(28453);const r={sidebar_custom_props:{tags:void 0}},a="Runtime Host Protocol",c={},h=[{value:"Transport",id:"transport",level:2},{value:"Framing",id:"framing",level:2},{value:"Messages",id:"messages",level:2},{value:"Operation",id:"operation",level:2},{value:"Initialization",id:"initialization",level:3},{value:"Remote Attestation",id:"remote-attestation",level:3},{value:"Host-to-runtime",id:"host-to-runtime",level:3},{value:"Transaction Batch Dispatch",id:"transaction-batch-dispatch",level:4},{value:"EnclaveRPC",id:"enclaverpc",level:4},{value:"Key Manager Policy Update",id:"key-manager-policy-update",level:4},{value:"Abort",id:"abort",level:4},{value:"Extensions",id:"extensions",level:4},{value:"Runtime-to-host",id:"runtime-to-host",level:3},{value:"EnclaveRPC to Remote Endpoints",id:"enclaverpc-to-remote-endpoints",level:4},{value:"Read-only Runtime Storage Access",id:"read-only-runtime-storage-access",level:4},{value:"Untrusted Local Storage Access",id:"untrusted-local-storage-access",level:4}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"runtime-host-protocol",children:"Runtime Host Protocol"})}),"\n",(0,o.jsx)(t.p,{children:"The Runtime Host Protocol (RHP) is a simple RPC protocol which is used to\ncommunicate between a runtime and an Oasis Core Compute Node."}),"\n",(0,o.jsx)(t.h2,{id:"transport",children:"Transport"}),"\n",(0,o.jsxs)(t.p,{children:["The RHP assumes a reliable byte stream oriented transport underneath. The only\ncurrent implementation uses AF_LOCAL sockets and ",(0,o.jsx)(t.a,{href:"https://edp.fortanix.com/docs/api/fortanix_sgx_abi/struct.Usercalls.html#streams",children:"Fortanix ABI streams"})," backed\nby shared memory to communicate with runtimes inside Intel SGX enclaves."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Runtime Execution",src:s(31029).A+""})}),"\n",(0,o.jsx)(t.h2,{id:"framing",children:"Framing"}),"\n",(0,o.jsxs)(t.p,{children:["All RHP messages use simple length-value framing with the value being encoded\nusing ",(0,o.jsx)(t.a,{href:"/core/encoding",children:"canonical CBOR"}),". The frames are serialized on the wire as follows:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"[4-byte message length (big endian)] [CBOR-serialized message]\n"})}),"\n",(0,o.jsx)(t.p,{children:"Maximum allowed message size is 16 MiB."}),"\n",(0,o.jsx)(t.h2,{id:"messages",children:"Messages"}),"\n",(0,o.jsxs)(t.p,{children:["Each ",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#Message",children:"message"})," can be either a request or a response as specified by the type\nfield. Each request is assigned a unique 64-bit sequence number by the caller to\nmake it possible to correlate responses."]}),"\n",(0,o.jsxs)(t.p,{children:["See the API reference (",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#Body",children:"Go"}),", ",(0,o.jsx)(t.a,{href:"https://github.com/oasisprotocol/oasis-core/tree/master/runtime/src/types.rs",children:"Rust"}),") for a list of all supported message bodies.\nIn case the request resulted in an error, the special ",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#Error",children:(0,o.jsx)(t.code,{children:"Error"})})," response body\nmust be used."]}),"\n",(0,o.jsx)(t.h2,{id:"operation",children:"Operation"}),"\n",(0,o.jsx)(t.p,{children:"RHP allows two forms of communication:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Host-to-runtime"})," where the host (compute node) submits requests to the\nruntime to handle and the runtime provides responses. All such request\n",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#Body",children:"messages"})," are prefixed with ",(0,o.jsx)(t.code,{children:"Runtime"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Runtime-to-host"})," where the runtime submits requests to the host and the\nhost provides responses. All such request ",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#Body",children:"messages"})," are prefixed with\n",(0,o.jsx)(t.code,{children:"Host"}),"."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"In its lifetime, from connection establishment to its termination, the RHP\nconnection goes through the following states:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.em,{children:"Uninitialized"})," is the default state of a newly created connection. In this\nstate the connection could be used either on the runtime side or the host\nside. To proceed to the next state, the connection must be initialized either\nas a runtime or as a host. The ",(0,o.jsx)(t.a,{href:"https://github.com/oasisprotocol/oasis-core/tree/master/runtime",children:"Rust implementation"})," only supports runtime\nmode while the ",(0,o.jsx)(t.a,{href:"https://github.com/oasisprotocol/oasis-core/tree/master/go/runtime/host/protocol",children:"Go implementation"})," can be initialized in either mode by using\neither ",(0,o.jsxs)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#Connection",children:[(0,o.jsx)(t.code,{children:"InitHost"})," or ",(0,o.jsx)(t.code,{children:"InitGuest"})]}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.em,{children:"Initializing"})," is the state when the connection is being initialized (see\nbelow for details). After a connection has been successfully initialized it\nwill transition into ",(0,o.jsx)(t.em,{children:"ready"})," state. If the initialization failed, it will\ninstead transition into ",(0,o.jsx)(t.em,{children:"closed"})," state."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.em,{children:"Ready"})," is the state when the connection can be used to exchange messages in\neither direction."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.em,{children:"Closed"})," is the state of the connection after it is considered closed. No\nmessages may be exchanged at this point."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"If either the runtime or the host generates an invalid message, either end may\nterminate the connection (and/or the runtime process)."}),"\n",(0,o.jsx)(t.h3,{id:"initialization",children:"Initialization"}),"\n",(0,o.jsxs)(t.p,{children:["Before a connection can be used, it must be initialized as either representing\nthe runtime end or the host (compute node) end. The ",(0,o.jsx)(t.a,{href:"https://github.com/oasisprotocol/oasis-core/tree/master/runtime",children:"Rust implementation"})," only\nsupports being initialized as the runtime and the ",(0,o.jsx)(t.a,{href:"https://github.com/oasisprotocol/oasis-core/tree/master/go/runtime/host/protocol",children:"Go implementation"})," is\ncurrently only used as the host. If one uses the ",(0,o.jsxs)(t.a,{href:"https://github.com/oasisprotocol/oasis-core/tree/master/runtime",children:[(0,o.jsx)(t.code,{children:"oasis-core-runtime"})," crate"]}),"\nto build a runtime, initialization is handled automatically."]}),"\n",(0,o.jsx)(t.p,{children:"The initialization procedure is driven by the host and it proceeds as follows:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The host sends ",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#RuntimeInfoRequest",children:(0,o.jsx)(t.code,{children:"RuntimeInfoRequest"})})," providing the runtime with its\n",(0,o.jsx)(t.a,{href:"/core/runtime/identifiers",children:"designated identifier"}),". The identifier comes from the ",(0,o.jsx)(t.a,{href:"/core/consensus/services/registry#runtimes",children:"registry service"})," in\nthe consensus layer."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The runtime must reply with a ",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#RuntimeInfoResponse",children:(0,o.jsx)(t.code,{children:"RuntimeInfoResponse"})})," specifying its own\nversion and the version of the runtime host protocol that it supports. If the\nprotocol version is incompatible, initialization fails."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"After the initialization procedure, the connection can be used for other\nmessages. In case the runtime is running in a trusted execution environment\n(TEE) like Intel SGX, the next required step is to perform remote attestation."}),"\n",(0,o.jsx)(t.h3,{id:"remote-attestation",children:"Remote Attestation"}),"\n",(0,o.jsxs)(t.p,{children:["When a runtime is executed in a TEE, it must perform remote attestation\nimmediately after initialization. The ",(0,o.jsx)(t.a,{href:"https://github.com/oasisprotocol/oasis-core/tree/master/runtime",children:"Rust implementation"})," also requires that\nremote attestation is periodically renewed and will start rejecting requests\notherwise. In case a runtime is not executed in a TEE, this step is skipped."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.em,{children:"NOTE: As currently Intel SGX is the only supported TEE, the elements of the\nremote attestation protocol are in some parts very specific to Intel SGX. This\nmay change in the future when support for additional TEEs is added."})}),"\n",(0,o.jsx)(t.p,{children:"Upon initialization the host performs the following steps:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.em,{children:"[Intel SGX]"})," The host obtains information for the runtime to be able to\ngenerate an attestation report. This includes talking to the AESM service and\nthe IAS configuration. The information includes the identity of the Quoting\nEnclave."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The host sends ",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#RuntimeCapabilityTEERakInitRequest",children:(0,o.jsx)(t.code,{children:"RuntimeCapabilityTEERakInitRequest"})})," passing the information\nrequired for the runtime to initialize its own ephemeral Runtime Attestation\nKey (RAK). The RAK is valid for as long as the runtime is running."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"The initialization then proceeds as follows, with the following steps also\nbeing performed as part of periodic re-attestation:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The host sends ",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#RuntimeCapabilityTEERakReportRequest",children:(0,o.jsx)(t.code,{children:"RuntimeCapabilityTEERakReportRequest"})})," requesting the runtime\nto generate an attestation report."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The runtime prepares an attestation report based on the information provided\nduring the first initialization step. It responds with\n",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#RuntimeCapabilityTEERakReportResponse",children:(0,o.jsx)(t.code,{children:"RuntimeCapabilityTEERakReportResponse"})})," containing the public part of the\nRAK, the attestation report (binding RAK to the TEE identity) and a replay\nprotection nonce."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.em,{children:"[Intel SGX]"})," The host proceeds to submit the attestation report to the\nQuoting Enclave to receive a quote. It submits the received quote to the\nIntel Attestation Service (IAS) to receive a signed Attestation Verification\nReport (AVR). It submits the AVR to the runtime by sending a\n",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#RuntimeCapabilityTEERakAvrRequest",children:(0,o.jsx)(t.code,{children:"RuntimeCapabilityTEERakAvrRequest"})}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.em,{children:"[Intel SGX]"})," The runtime verifies the validity of the AVR, making sure that\nit is not a replay and that it in fact contains the correct enclave identity\nand the RAK binding."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Upon successful verification the runtime is now ready to accept requests. As\nmentioned the attestation procedure must be performed periodically by the host\nas otherwise the runtime may start rejecting requests."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["The compute node will submit remote attestation information to the consensus\n",(0,o.jsx)(t.a,{href:"/core/consensus/services/registry#runtimes",children:"registry service"})," as part of its ",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/common/node?tab=doc#Node",children:"node registration descriptor"}),". The registry\nservice will verify that the submitted AVR is in fact valid and corresponds to\nthe registered runtime enclave identity. It will reject node registrations\notherwise."]}),"\n",(0,o.jsx)(t.h3,{id:"host-to-runtime",children:"Host-to-runtime"}),"\n",(0,o.jsx)(t.p,{children:"The following section describes the calls that a host can make to request\nprocessing from the runtime after successfully performing initialization (and\ninitial remote attestation if running in a TEE)."}),"\n",(0,o.jsx)(t.h4,{id:"transaction-batch-dispatch",children:"Transaction Batch Dispatch"}),"\n",(0,o.jsxs)(t.p,{children:["When a compute node needs to verify whether individual transactions are valid\nit can optionally request the runtime to perform a simplified transaction check.\nIt can do this by sending a ",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#RuntimeCheckTxBatchRequest",children:(0,o.jsx)(t.code,{children:"RuntimeCheckTxBatchRequest"})})," message. The runtime\nshould perform the required non-expensive checks, but should not fully execute\nthe transactions."]}),"\n",(0,o.jsxs)(t.p,{children:["When a compute node receives a batch of transactions to process from the\ntransaction scheduler executor, it passes the batch to the runtime via the\n",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#RuntimeExecuteTxBatchRequest",children:(0,o.jsx)(t.code,{children:"RuntimeExecuteTxBatchRequest"})})," message. The runtime must execute the\ntransactions in the given batch and produce a set of state changes (storage\nupdates for the output and state roots). In case the runtime is running in a TEE\nthe execution results must be signed by the Runtime Attestation Key (see above)."]}),"\n",(0,o.jsx)(t.h4,{id:"enclaverpc",children:"EnclaveRPC"}),"\n",(0,o.jsx)(t.h4,{id:"key-manager-policy-update",children:"Key Manager Policy Update"}),"\n",(0,o.jsx)(t.h4,{id:"abort",children:"Abort"}),"\n",(0,o.jsxs)(t.p,{children:["The host can request the runtime to abort processing the current batch by\nsending the ",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#RuntimeAbortRequest",children:(0,o.jsx)(t.code,{children:"RuntimeAbortRequest"})})," message. The request does not take any\narguments. In case the response does not indicate an error the abort is deemed\nsuccessful by the host."]}),"\n",(0,o.jsx)(t.p,{children:"In case the runtime does not reply quickly enough the host may terminate the\nruntime and start a new instance."}),"\n",(0,o.jsx)(t.h4,{id:"extensions",children:"Extensions"}),"\n",(0,o.jsxs)(t.p,{children:["RHP provides a way for runtimes to support custom protocol extensions by\nutilizing the ",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#RuntimeLocalRPCCallRequest",children:(0,o.jsx)(t.code,{children:"RuntimeLocalRPCCallRequest"})})," and ",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#RuntimeLocalRPCCallResponse",children:(0,o.jsx)(t.code,{children:"RuntimeLocalRPCCallResponse"})}),"\nmessages."]}),"\n",(0,o.jsx)(t.h3,{id:"runtime-to-host",children:"Runtime-to-host"}),"\n",(0,o.jsx)(t.p,{children:"The following section describes the calls that a runtime can make to request\nprocessing from the host (or the wider distributed network on host's behalf)."}),"\n",(0,o.jsx)(t.h4,{id:"enclaverpc-to-remote-endpoints",children:"EnclaveRPC to Remote Endpoints"}),"\n",(0,o.jsx)(t.h4,{id:"read-only-runtime-storage-access",children:"Read-only Runtime Storage Access"}),"\n",(0,o.jsxs)(t.p,{children:["The host exposes the ",(0,o.jsx)(t.a,{href:"/core/mkvs#read-syncer",children:"MKVS read syncer"})," interface (via the\n",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#HostStorageSyncRequest",children:(0,o.jsx)(t.code,{children:"HostStorageSyncRequest"})})," message) to enable runtimes read-only access to\nglobal runtime storage."]}),"\n",(0,o.jsx)(t.h4,{id:"untrusted-local-storage-access",children:"Untrusted Local Storage Access"}),"\n",(0,o.jsxs)(t.p,{children:["The host exposes a simple key-value local store that can be used by the runtime\nto store arbitrary instance-specific data. ",(0,o.jsx)(t.strong,{children:"Note that if the runtime is running\nin a TEE this store must be treated as UNTRUSTED as the host may perform\narbitrary attacks. The runtime should use TEE-specific sealing to ensure\nintegrity and confidentiality of any stored data."})]}),"\n",(0,o.jsxs)(t.p,{children:["There are two local storage operations, namely get and set, exposed via\n",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#HostLocalStorageGetRequest",children:(0,o.jsx)(t.code,{children:"HostLocalStorageGetRequest"})})," and ",(0,o.jsx)(t.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/host/protocol?tab=doc#HostLocalStorageSetRequest",children:(0,o.jsx)(t.code,{children:"HostLocalStorageSetRequest"})})," messages,\nrespectively."]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);