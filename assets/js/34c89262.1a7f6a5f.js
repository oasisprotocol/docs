"use strict";(globalThis.webpackChunkdocs_oasis_io=globalThis.webpackChunkdocs_oasis_io||[]).push([[7194],{21040:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"adrs/0015-vrf-per-block-entropy","title":"ADR 0015: Randomized Paratime Proposer Selection","description":"Component","source":"@site/docs/adrs/0015-vrf-per-block-entropy.md","sourceDirName":"adrs","slug":"/adrs/0015-vrf-per-block-entropy","permalink":"/adrs/0015-vrf-per-block-entropy","draft":false,"unlisted":false,"editUrl":"https://github.com/oasisprotocol/adrs/edit/main/0015-vrf-per-block-entropy.md","tags":[],"version":"current","lastUpdatedAt":1754295238000,"frontMatter":{"sidebar_custom_props":{}},"sidebar":"adrs","previous":{"title":"ADR 0014: Signing Runtime Transactions with Hardware Wallet","permalink":"/adrs/0014-runtime-signing-tx-with-hardware-wallet"},"next":{"title":"ADR 0016: Consensus Parameters Change Proposal","permalink":"/adrs/0016-consensus-parameters-change-proposal"}}');var i=t(74848),s=t(28453);const o={sidebar_custom_props:{tags:void 0}},a="ADR 0015: Randomized Paratime Proposer Selection",l={},c=[{value:"Component",id:"component",level:2},{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Vote extension",id:"vote-extension",level:3},{value:"Proposer selection",id:"proposer-selection",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"adr-0015-randomized-paratime-proposer-selection",children:"ADR 0015: Randomized Paratime Proposer Selection"})}),"\n",(0,i.jsx)(n.h2,{id:"component",children:"Component"}),"\n",(0,i.jsx)(n.p,{children:"Oasis Core"}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"2022-09-14: Initial import"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,i.jsx)(n.p,{children:"Proposed"}),"\n",(0,i.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,i.jsxs)(n.p,{children:["The paratime block proposer currently is selected via a round-robin algorithm,\nand it is trivial to determine the block proposer well in advance.  This ADR\nproposes having a mechanism for generating per-consensus block entropy via\nECVRF",(0,i.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/",children:"1"}),", and randomizing the Paratime block proposer."]}),"\n",(0,i.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,i.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsx)(n.p,{children:"Let each node have a distinct long-term VRF keypair, that is published as\npart of the node's descriptor (as per ADR 0010)."}),"\n",(0,i.jsxs)(n.p,{children:["Let Tendermint actually implement ",(0,i.jsx)(n.code,{children:"ExtendVote"}),"/",(0,i.jsx)(n.code,{children:"VerifyVoteExtension"})," as\nper certain versions of the ABCI++ spec",(0,i.jsx)(n.a,{href:"https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-013-abci%2B%2B.md",children:"2"}),".  Note that it appears that this\nwill NOT be in Tendermint 0.37.x, but instead is scheduled for a later\nrelease."]}),"\n",(0,i.jsx)(n.h3,{id:"vote-extension",children:"Vote extension"}),"\n",(0,i.jsxs)(n.p,{children:["ABCI++ introduces a notion of an application defined ",(0,i.jsx)(n.code,{children:"vote_extension"})," blob\nthat is set by the tendermint block proposer, and verified by all of the\nvoters.  Oasis will use the following datastructure, serialized to canonical\nCBOR, and signed with the node's consensus signing key."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:'type OasisVoteExtension struct {\n  // Pi is the proposer\'s VRF proof for the current block height.\n  Pi []byte `json:"pi"`\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"For the genesis block +1 (No previous beta), let the VRF alpha_string input\nbe derived as:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:'TupleHash256((chain_context, I2OSP(height,8)), 256, "oasis-core:tm-vrf/alpha")'})}),"\n",(0,i.jsx)(n.p,{children:"For subsequent blocks, let the VRF alpha_string input be derived as:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'TupleHash256((chain_context, I2OSP(height,8), prev_beta), 256, "oasis-core:tm-vrf/alpha")'}),"\nwhere prev_beta is the beta_string output from the previous height's ECVRF\nproof."]}),"\n",(0,i.jsxs)(n.p,{children:["Blocks must have a valid ",(0,i.jsx)(n.code,{children:"OasisVoteExtension"})," blob to be considered valid,\nand nodes MUST use the same ECVRF key for the entire epoch (key changes\nmid-epoch are ignored till the epoch transition) to prevent the proposer\nfrom regenerating the ECVRF key repeatedly to fish for entropy output."]}),"\n",(0,i.jsx)(n.h3,{id:"proposer-selection",children:"Proposer selection"}),"\n",(0,i.jsx)(n.p,{children:"Instead of round-robin through the per-epoch list of primary (non-backup)\nworkers, the index for the node can be selected as thus:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:'seed = TupleHash256((chain_context, I2OSP(height,8), runtime_id, pi), 256, "oasis-core:tm-vrf/paratime")\ndrbg = drbg.New(crypto.SHA512, seed, nil, "BlockProposer")\nrng = rand.New(mathrand.New(drbg))\n\nl := len(primary_nodes)\nprimary_index = int(rng.Int63n(l))\n'})}),"\n",(0,i.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,i.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,i.jsx)(n.p,{children:"The paratime block proposer(s) will be randomized."}),"\n",(0,i.jsx)(n.p,{children:"This can be done without having to patch tendermint."}),"\n",(0,i.jsx)(n.p,{children:"In theory, the system will have a way to generate entropy at the consensus\nlayer again."}),"\n",(0,i.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,i.jsx)(n.p,{children:"The tendermint block proposer still will be selected via a round robin\nalgorithm.  Note that Oasis does not have smart contracts at that level so\nthe impact of being able to predict the block proposer there is less\nsignificant than other systems."}),"\n",(0,i.jsx)(n.p,{children:"People may be tempted to abuse this entropy for other things (eg: inside\nparatimes), which would be incorrect (block proposer can cheat)."}),"\n",(0,i.jsx)(n.p,{children:"This relies on interfaces exposed by ABCI++, which appear to no longer\nbe part of 0.37.x, so it is unknown when this will be possible to implement."}),"\n",(0,i.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(96540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);