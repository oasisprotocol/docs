"use strict";(globalThis.webpackChunkdocs_oasis_io=globalThis.webpackChunkdocs_oasis_io||[]).push([[254],{11470:(e,n,t)=>{t.d(n,{A:()=>k});var s=t(96540),r=t(34164),i=t(17559),a=t(23104),o=t(56347),c=t(205),l=t(57485),d=t(31682),h=t(70679);function p(e){return s.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,s.useMemo)(()=>{const e=n??function(e){return p(e).map(({props:{value:e,label:n,attributes:t,default:s}})=>({value:e,label:n,attributes:t,default:s}))}(t);return function(e){const n=(0,d.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function m({value:e,tabValues:n}){return n.some(n=>n.value===e)}function g({queryString:e=!1,groupId:n}){const t=(0,o.W6)(),r=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,l.aZ)(r),(0,s.useCallback)(e=>{if(!r)return;const n=new URLSearchParams(t.location.search);n.set(r,e),t.replace({...t.location,search:n.toString()})},[r,t])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,i=u(e),[a,o]=(0,s.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:i})),[l,d]=g({queryString:t,groupId:r}),[p,f]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,r]=(0,h.Dv)(n);return[t,(0,s.useCallback)(e=>{n&&r.set(e)},[n,r])]}({groupId:r}),w=(()=>{const e=l??p;return m({value:e,tabValues:i})?e:null})();(0,c.A)(()=>{w&&o(w)},[w]);return{selectedValue:a,selectValue:(0,s.useCallback)(e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);o(e),d(e),f(e)},[d,f,i]),tabValues:i}}var w=t(92303);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(74848);function v({className:e,block:n,selectedValue:t,selectValue:s,tabValues:i}){const o=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),l=e=>{const n=e.currentTarget,r=o.indexOf(n),a=i[r].value;a!==t&&(c(n),s(a))},d=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},e),children:i.map(({value:e,label:n,attributes:s})=>(0,b.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{o.push(e)},onKeyDown:d,onClick:l,...s,className:(0,r.A)("tabs__item",x.tabItem,s?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function j({lazy:e,children:n,selectedValue:t}){const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=i.find(e=>e.props.value===t);return e?(0,s.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:i.map((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function y(e){const n=f(e);return(0,b.jsxs)("div",{className:(0,r.A)(i.G.tabs.container,"tabs-container",x.tabList),children:[(0,b.jsx)(v,{...n,...e}),(0,b.jsx)(j,{...n,...e})]})}function k(e){const n=(0,w.A)();return(0,b.jsx)(y,{...e,children:p(e.children)},String(n))}},19365:(e,n,t)=>{t.d(n,{A:()=>a});t(96540);var s=t(34164);const r={tabItem:"tabItem_Ymn6"};var i=t(74848);function a({children:e,hidden:n,className:t}){return(0,i.jsx)("div",{role:"tabpanel",className:(0,s.A)(r.tabItem,t),hidden:n,children:e})}},25194:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/siwe-sapphire-flow.mmd-e4e42cc65d42ee1146949b4d9fb0c719.svg"},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(96540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},37281:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/siwe-login-eb7086a37743f99527e28957927ee3ef.png"},62673:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>c,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"build/sapphire/develop/authentication","title":"View-Call Authentication","description":"Authenticate users with your confidential contracts","source":"@site/docs/build/sapphire/develop/authentication.md","sourceDirName":"build/sapphire/develop","slug":"/build/sapphire/develop/authentication","permalink":"/build/sapphire/develop/authentication","draft":false,"unlisted":false,"editUrl":"https://github.com/oasisprotocol/sapphire-paratime/edit/main/docs/develop/authentication.md","tags":[],"version":"current","lastUpdatedAt":1760874442000,"frontMatter":{"description":"Authenticate users with your confidential contracts","sidebar_custom_props":{}},"sidebar":"developers","previous":{"title":"Browser Support","permalink":"/build/sapphire/develop/browser"},"next":{"title":"Gasless Transactions","permalink":"/build/sapphire/develop/gasless"}}');var r=t(74848),i=t(28453),a=t(11470),o=t(19365);const c={description:"Authenticate users with your confidential contracts",sidebar_custom_props:{tags:void 0}},l="View-Call Authentication",d={},h=[{value:"How Sapphire Executes Contract Calls",id:"how-sapphire-executes-contract-calls",level:2},{value:"Authenticated view calls",id:"authenticated-view-calls",level:2},{value:"via SIWE token",id:"via-siwe-token",level:3},{value:"A few words about the SIWE domain parameter",id:"siwe-domain",level:4},{value:"via signed queries",id:"via-signed-queries",level:3}];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"view-call-authentication",children:"View-Call Authentication"})}),"\n",(0,r.jsxs)(n.p,{children:['User impersonation on Ethereum and other "transparent EVMs" isn\'t a problem\nbecause ',(0,r.jsx)(n.strong,{children:"everybody"})," can see ",(0,r.jsx)(n.strong,{children:"all"})," data. However, the Sapphire confidential\nEVM prevents contracts from revealing confidential information to the wrong\nparty (account or contract)\u2014for this reason we cannot allow arbitrary\nimpersonation of any ",(0,r.jsx)(n.code,{children:"msg.sender"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"In Sapphire, you need to consider the following types of contract calls:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Contract to contract calls"})," (also known as ",(0,r.jsx)(n.em,{children:"internal calls"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"msg.sender"})," is set to the address corresponding to the caller function. If\na contract calls another contract in a way which could reveal sensitive\ninformation, the calling contract must implement access control or\nauthentication."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Unauthenticted view calls"})," (queries using ",(0,r.jsx)(n.code,{children:"eth_call"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"eth_call"})," queries used to invoke contract functions will always have the\n",(0,r.jsx)(n.code,{children:"msg.sender"})," parameter set to ",(0,r.jsx)(n.code,{children:"address(0x0)"})," on Sapphire. This is regardless\nof any ",(0,r.jsx)(n.code,{children:"from"})," overrides passed on the client side for simulating the query."]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"Calldata end-to-end encryption has nothing to do with authentication.\nAlthough the calls may be unauthenticated they can still be encrypted, and\nthe other way around!"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Authenticated view calls"})," (via SIWE token)"]}),"\n",(0,r.jsxs)(n.p,{children:["Developer authenticates the view call explicitly by deriving a message\nsender from the SIWE token. This token is provided as a separate parameter\nto the contract function. The derived address can then be used for\nauthentication in place of ",(0,r.jsx)(n.code,{children:"msg.sender"}),". Otherwise, such view call behaves\nthe same way as the unauthenticated view calls above and built-in\n",(0,r.jsx)(n.code,{children:"msg.sender"})," is ",(0,r.jsx)(n.code,{children:"address(0x0)"}),". This approach is most appropriate for\nfrontend dApps."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Authenticated view calls"})," (via signed queries)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://eips.ethereum.org/EIPS/eip-712",children:"EIP-712"})," defines a format for signing view calls with the keypair of your\nEthereum account. Sapphire will validate such signatures and automatically\nset the ",(0,r.jsx)(n.code,{children:"msg.sender"})," parameter in your contract to the address of the\nsigning account. This method is most appropriate for backend services\nbecause frontend applications would require user interaction each time."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Transactions"})," (authenticated by signature)"]}),"\n",(0,r.jsxs)(n.p,{children:["When a transaction is submitted it is signed by a keypair (thus costs gas\nand can make state updates) and the ",(0,r.jsx)(n.code,{children:"msg.sender"})," will be set to the address of\nthe signing account."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"how-sapphire-executes-contract-calls",children:"How Sapphire Executes Contract Calls"}),"\n",(0,r.jsx)(n.p,{children:"Let's see how Sapphire executes contract calls for each call variant presented\nabove. Consider the following Solidity code:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"contract Example {\n    address _owner;\n    constructor () {\n        _owner = msg.sender;\n    }\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the sample above, assuming we're calling from the same contract or account\nwhich created the contract, calling ",(0,r.jsx)(n.code,{children:"isOwner"})," will return:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"true"}),", if called via the contract which created it"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"false"}),", for unauthenticated ",(0,r.jsx)(n.code,{children:"eth_call"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"false"}),", since the contract has no SIWE implementation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"true"}),", for signed view call using the wrapped client (",(0,r.jsx)(n.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/sapphire-paratime/clients/go#WrapClient",children:"Go"}),",\n",(0,r.jsx)(n.a,{href:"https://api.docs.oasis.io/py/sapphirepy/sapphirepy.html#sapphirepy.sapphire.wrap",children:"Python"}),") with signer attached"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"true"}),", if called via transaction"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Now that we've covered basics, let's look more closely at the ",(0,r.jsx)(n.em,{children:"authenticated\nview calls"}),". These are crucial for building confidential smart contracts on\nSapphire."]}),"\n",(0,r.jsx)(n.h2,{id:"authenticated-view-calls",children:"Authenticated view calls"}),"\n",(0,r.jsx)(n.p,{children:"Consider this slightly extended version of the contract above. Only the owner is\nallowed to store and retrieve secret message:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'contract MessageBox {\n    address private _owner;\n    string private _message;\n\n    modifier onlyOwner() {\n        if (msg.sender != _owner) {\n            revert("not allowed");\n        }\n        _;\n    }\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    function getSecretMessage() external view onlyOwner returns (string memory) {\n        return _message;\n    }\n\n    function setSecretMessage(string calldata message) external onlyOwner {\n        _message = message;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"via-siwe-token",children:"via SIWE token"}),"\n",(0,r.jsxs)(n.p,{children:['SIWE stands for "Sign-In with Ethereum" and is formally defined in ',(0,r.jsx)(n.a,{href:"https://eips.ethereum.org/EIPS/eip-4361",children:"EIP-4361"}),".\nThe initial use case for SIWE involved using your Ethereum account as a form of\nauthentication for off-chain services (providing an alternative to user names\nand passwords). The MetaMask wallet quickly adopted the standard and it became a\nde-facto login mechanism in the Web3 world. An informative pop-up for logging\ninto a SIWE-enabled website looks like this:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"MetaMask Log-In confirmation",src:t(37281).A+"",width:"360",height:"710"})}),"\n",(0,r.jsxs)(n.p,{children:["After a user agrees by signing the SIWE login message above, the signature is\nverified by the website backend or by a 3rd party ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Single_sign-on",children:"single sign-on"})," service. This\nis done only once per session\u2014during login. A successful login generates a token\nthat is used for the remainder of the session."]}),"\n",(0,r.jsxs)(n.p,{children:["In contrast to transparent EVM chains, ",(0,r.jsx)(n.strong,{children:"Sapphire simplifies dApp design,\nimproves trust, and increases the usability of SIWE messages through extending\nmessage parsing and verification to on-chain computation"}),". This feature (unique\nto Sapphire) removes the need to develop and maintain separate dApp backend\nservices just for SIWE authentication. Let's take a look at an example\nauthentication flow:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"SIWE authentication flow on Sapphire",src:t(25194).A+"",width:"715",height:"981"})}),"\n",(0,r.jsxs)(n.p,{children:["Consider the ",(0,r.jsx)(n.code,{children:"MessageBox"})," contract from ",(0,r.jsx)(n.a,{href:"#authenticated-view-calls",children:"above"}),", and\nlet's extend it with ",(0,r.jsx)(n.a,{href:"https://api.docs.oasis.io/sol/sapphire-contracts/contracts/auth/SiweAuth.sol/contract.SiweAuth.html",children:"SiweAuth"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'import {SiweAuth} from "@oasisprotocol/sapphire-contracts/contracts/auth/SiweAuth.sol";\n\ncontract MessageBox is SiweAuth {\n  address private _owner;\n  string private _message;\n\n  modifier onlyOwner(bytes memory token) {\n    if (msg.sender != _owner && authMsgSender(token) != _owner) {\n        revert("not allowed");\n    }\n    _;\n  }\n\n  constructor(string memory domain) SiweAuth(domain) {\n    _owner = msg.sender;\n  }\n\n  function getSecretMessage(bytes memory token) external view onlyOwner(token) returns (string memory) {\n    return _message;\n  }\n\n  function setSecretMessage(string calldata message) external onlyOwner(bytes("")) {\n    _message = message;\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"We made the following changes:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"In the constructor, we need to define the domain name where the dApp frontend\nwill be deployed. This domain is included inside the SIWE log-in message\nand is verified by the user-facing wallet to make sure they are accessing the\ncontract from a legitimate domain."}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"onlyOwner"})," modifier is extended with an optional ",(0,r.jsx)(n.code,{children:"bytes memory token"}),"\nparameter and is considered in the case of invalid ",(0,r.jsx)(n.code,{children:"msg.sender"})," value. The\nsame modifier is used for authenticating both SIWE queries and the\ntransactions."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"getSecretMessage"})," was extended with the ",(0,r.jsx)(n.code,{children:"bytes memory token"})," session token."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"On the client side, the code running inside a browser needs to make sure that\nthe session token for making authenticated calls is valid. If not, the browser\nrequests a wallet to sign a log-in message and fetch a fresh session token."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import {SiweMessage} from 'siwe';\nimport { ethers } from 'hardhat'\n\nlet token = '';\n\nasync function getSecretMessage(): Promise<Message> {\n  const messageBox = await ethers.getContractAt('MessageBox', '0x5FbDB2315678afecb367f032d93F642f64180aa3');\n\n  if (token == '') { // Stored in browser session.\n    const domain = await messageBox.domain();\n    const siweMsg = new SiweMessage({\n      domain,\n      address: addr, // User's selected account address.\n      uri: `http://${domain}`,\n      version: \"1\",\n      chainId: 0x5aff, // Sapphire Testnet\n    }).toMessage();\n    const sig = ethers.Signature.from((await window.ethereum.getSigner(addr)).signMessage(siweMsg));\n    token = await messageBox.login(siweMsg, sig);\n  }\n\n  return messageBox.getSecretMessage(token);\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"siwe-domain",children:"A few words about the SIWE domain parameter"}),"\n",(0,r.jsxs)(n.p,{children:["During contract deployment you have to provide ",(0,r.jsx)(n.strong,{children:"the domain"})," where the web\ncontent of your dApp will be hosted at. MetaMask will check whether the domain\nshown in the user's browser window matches the one provided in the SIWE message\nused for logging in and then warn the user if there is a discrepancy. On the\nother hand\u2014if the SIWE message is forged to match the (exploited) web site\ndomain, the on-chain ",(0,r.jsx)(n.a,{href:"https://api.docs.oasis.io/sol/sapphire-contracts/contracts/auth/SiweAuth.sol/contract.SiweAuth.html",children:"SiweAuth"})," message will fail validation and prevent the\nuser from obtaining a valid token."]}),"\n",(0,r.jsxs)(n.p,{children:["When deploying your contract, the provided domain ",(0,r.jsxs)(n.strong,{children:["should include the host\nchunk of the ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax",children:"URI"}),", including any subdomains, and optionally the port"]}),". No\nscheme (e.g. ",(0,r.jsx)(n.code,{children:"http://"}),", ",(0,r.jsx)(n.code,{children:"https://"}),") or path (e.g. ",(0,r.jsx)(n.code,{children:"/my-app/login"}),") should be\nincluded. If you wish to enforce authentication only on a specific\nport, provide it alongside the domain, e.g. ",(0,r.jsx)(n.code,{children:"mydomain.com:12345"}),". Otherwise,\nMetaMask will consider any port valid."]}),"\n",(0,r.jsxs)(n.p,{children:["The visibility of ",(0,r.jsx)(n.code,{children:"_domain"})," in ",(0,r.jsx)(n.a,{href:"https://api.docs.oasis.io/sol/sapphire-contracts/contracts/auth/SiweAuth.sol/contract.SiweAuth.html",children:"SiweAuth"})," is ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"internal"})}),". By default, a\npublic getter is implemented, so a web app can automatically obtain a domain\nname when generating the SIWE message. No setters are provided in keeping the\ndomain immutable. If needed, feel free to implement a setter in your contract\nwith appropriate authentication mechanisms (e.g. ",(0,r.jsx)(n.code,{children:"onlyOwner"})," modifier). For\ntraceability, we also suggest to ",(0,r.jsx)(n.strong,{children:"emit an event"})," when the domain is\nchanged as transactions may be encrypted."]}),"\n",(0,r.jsx)(n.admonition,{title:"Example: Starter project",type:"info",children:(0,r.jsxs)(n.p,{children:["To see a running example of the TypeScript SIWE code including the Hardhat\ntests, Node.js and the browser, check out the official Oasis ",(0,r.jsx)(n.a,{href:"https://github.com/oasisprotocol/demo-starter",children:"demo-starter"}),"\nproject. The SIWE authentication is implemented on the backend as a\n",(0,r.jsx)(n.a,{href:"https://github.com/oasisprotocol/demo-starter/blob/master/backend/hardhat.config.ts",children:"Hardhat task"}),", in ",(0,r.jsx)(n.a,{href:"https://github.com/oasisprotocol/demo-starter/blob/master/backend/test/MessageBox.ts",children:"unit tests"}),", and on the frontend within the\n",(0,r.jsx)(n.a,{href:"https://github.com/oasisprotocol/demo-starter/blob/master/frontend/src/providers/Web3AuthProvider.tsx",children:"Web3 Auth provider"})," code."]})}),"\n",(0,r.jsx)(n.admonition,{title:"Sapphire TypeScript wrapper?",type:"tip",children:(0,r.jsxs)(n.p,{children:["While the ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/@oasisprotocol/sapphire-paratime",children:"Sapphire TypeScript wrapper"})," offers convenient end-to-end\nencryption for contract calls and transactions, using the TypeScript wrapper\nis required for SIWE security if you trust your Web3 endpoint. The token\ngeneration occurs inside the Sapphire's TEE and the communication with your\nWeb3 endpoint is secured via HTTPS."]})}),"\n",(0,r.jsx)(n.h3,{id:"via-signed-queries",children:"via signed queries"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://eips.ethereum.org/EIPS/eip-712",children:"EIP-712"})," proposed a method to show data to the user in a structured fashion so\nthey can verify it before signing. In the browser however, apps requiring signed\nview calls would trigger user interaction with their wallet each time\u2014sometimes\neven multiple times per page\u2014which is bad UX that frustrates users. Backend\nservices on the other hand often have direct access to an Ethereum wallet (e.g.\na secret key stored in the environment variable) without needing user\ninteraction. This is possible because a backend service connects to a trusted\nsite and executes trusted code, so it's fine to sign the necessary view calls\nnon interactively."]}),"\n",(0,r.jsxs)(n.p,{children:["The Sapphire wrappers for ",(0,r.jsx)(n.a,{href:"https://github.com/oasisprotocol/sapphire-paratime/tree/main/clients/go",children:"Go"})," and ",(0,r.jsx)(n.a,{href:"https://github.com/oasisprotocol/sapphire-paratime/tree/main/clients/py",children:"Python"})," will ",(0,r.jsx)(n.strong,{children:"sign any view\ncall"})," you make to a contract deployed on Sapphire using the aforementioned\n",(0,r.jsx)(n.a,{href:"https://eips.ethereum.org/EIPS/eip-712",children:"EIP-712"}),". Suppose we want to store the private key of an account used to sign\nthe view calls inside a ",(0,r.jsx)(n.code,{children:"PRIVATE_KEY"})," environment variable. The following\nsnippets demonstrate how to trigger signed queries ",(0,r.jsxs)(n.strong,{children:["without any changes to the\noriginal ",(0,r.jsx)(n.code,{children:"MessageBox"})," contract from ",(0,r.jsx)(n.a,{href:"#authenticated-view-calls",children:"above"})]}),"."]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsxs)(o.A,{value:"Go",children:[(0,r.jsxs)(n.p,{children:["Wrap the existing Ethereum client by calling the\n",(0,r.jsx)(n.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/sapphire-paratime/clients/go#WrapClient",children:(0,r.jsx)(n.code,{children:"WrapClient()"})})," helper and provide the signing logic. Then,\nall subsequent view calls will be signed. For example:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'import (\n    "context"\n    "crypto/ecdsa"\n\n    "github.com/ethereum/go-ethereum/accounts/abi/bind"\n    "github.com/ethereum/go-ethereum/common"\n    "github.com/ethereum/go-ethereum/crypto"\n    "github.com/ethereum/go-ethereum/ethclient"\n    \n    sapphire "github.com/oasisprotocol/sapphire-paratime/clients/go"\n\n    messageBox "demo-starter/contracts/message-box"\n)\n\nfunc GetC10lMessage() (string, error) {\n    client, err = ethclient.Dial("https://testnet.sapphire.oasis.io")\n    if err != nil {\n        return "", err\n    }\n\t\n    sk, err = crypto.HexToECDSA(os.Getenv("PRIVATE_KEY"))\n    addr := crypto.PubkeyToAddress(*sk.Public().(*ecdsa.PublicKey))\n\n    wrappedClient, err := sapphire.WrapClient(c.Client, func(digest [32]byte) ([]byte, error) {\n        return crypto.Sign(digest[:], sk)\n    })\n    if err != nil {\n        return "", fmt.Errorf("unable to wrap backend: %v", err)\n    }\n\n    mb, err := messageBox.NewMessageBox(common.HexToAddress("0x5FbDB2315678afecb367f032d93F642f64180aa3"), wrappedClient)\n    if err != nil {\n        return "", fmt.Errorf("Unable to get instance of contract: %v", err)\n    }\n\t\n    msg, err := mb.GetSecretMessage(&bind.CallOpts{From: addr}) // Don\'t forget to pass callOpts!\n    if err != nil {\n        return "", fmt.Errorf("failed to retrieve message: %v", err)\n    }\n\t\n    return msg, nil\n}\n'})}),(0,r.jsx)(n.admonition,{title:"Example: Oasis starter in Go",type:"info",children:(0,r.jsxs)(n.p,{children:["To see a running example of the Go code including the end-to-end encryption\nand signed queries check out the official ",(0,r.jsx)(n.a,{href:"https://github.com/oasisprotocol/demo-starter-go",children:"Oasis starter project for Go"}),"."]})})]}),(0,r.jsxs)(o.A,{value:"Python",children:[(0,r.jsxs)(n.p,{children:["Wrap the existing Web3 client by calling the\n",(0,r.jsx)(n.a,{href:"https://api.docs.oasis.io/py/sapphirepy/sapphirepy.html#sapphirepy.sapphire.wrap",children:(0,r.jsx)(n.code,{children:"wrap()"})})," helper and provide the signing logic. Then,\nall subsequent view calls will be signed. For example:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from web3 import Web3\nfrom web3.middleware import construct_sign_and_send_raw_middleware\nfrom eth_account.signers.local import LocalAccount\nfrom eth_account import Account\n\nfrom sapphirepy import sapphire\n\ndef get_c10l_message(address: str, network_name: Optional[str] = "sapphire-localnet") -> str:\n    w3 = Web3(Web3.HTTPProvider(sapphire.NETWORKS[network_name]))\n    account: LocalAccount = Account.from_key(os.environ.get("PRIVATE_KEY"))\n    w3.middleware_onion.add(construct_sign_and_send_raw_middleware(account))\n    w3 = sapphire.wrap(w3, account)\n    \n    compiled_contract = json.load("MessageBox_compiled.json")\n    contract_data = compiled_contract["contracts"]["MessageBox.sol"]["MessageBox"]\n    message_box = w3.eth.contract(address=address, abi=contract_data["abi"])\n    \n    return message_box.functions.message().call()\n'})}),(0,r.jsx)(n.admonition,{title:"Example: Oasis starter in Python",type:"info",children:(0,r.jsxs)(n.p,{children:["To see a running example of the Python code including the end-to-end\nencryption and signed queries, check out the official ",(0,r.jsx)(n.a,{href:"https://github.com/oasisprotocol/demo-starter-py",children:"Oasis starter project\nfor Python"}),"."]})})]})]}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsxs)(n.p,{children:["If your smart contract needs to support view calls from both the frontend and\nthe backend, then take the ",(0,r.jsx)(n.a,{href:"#via-siwe-token",children:"SIWE approach"}),". The backend\nimplementation then depends on your programming language:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Go and Python"}),": Pass an empty string as a ",(0,r.jsx)(n.code,{children:"token"})," parameter to your smart\ncontract and let the wrapper sign the view call using EIP-712. Since\n",(0,r.jsx)(n.code,{children:"msg.sender"})," will be defined, the ",(0,r.jsx)(n.code,{children:"isOwner"})," modifier will pass just fine."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TypeScript"}),": Recycle the frontend client-side code\n",(0,r.jsx)(n.a,{href:"#via-siwe-token",children:"from above"})," to generate the SIWE message, perform the\nauthentication and pass it in the view call. You can check out the\ndemo-starter's ",(0,r.jsx)(n.a,{href:"https://github.com/oasisprotocol/demo-starter/blob/master/backend/hardhat.config.ts",children:"Hardhat task"})," and ",(0,r.jsx)(n.a,{href:"https://github.com/oasisprotocol/demo-starter/blob/master/backend/test/MessageBox.ts",children:"unit tests"})," for a working example."]}),"\n"]})]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);