"use strict";(globalThis.webpackChunkdocs_oasis_io=globalThis.webpackChunkdocs_oasis_io||[]).push([[2075],{24143:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"adrs/0004-runtime-governance","title":"ADR 0004: Runtime Governance","description":"Component","source":"@site/docs/adrs/0004-runtime-governance.md","sourceDirName":"adrs","slug":"/adrs/0004-runtime-governance","permalink":"/adrs/0004-runtime-governance","draft":false,"unlisted":false,"editUrl":"https://github.com/oasisprotocol/adrs/edit/main/0004-runtime-governance.md","tags":[],"version":"current","lastUpdatedAt":1754295238000,"frontMatter":{"sidebar_custom_props":{}},"sidebar":"adrs","previous":{"title":"ADR 0003: Consensus/Runtime Token Transfer","permalink":"/adrs/0003-consensus-runtime-token-transfer"},"next":{"title":"ADR 0005: Runtime Compute Node Slashing","permalink":"/adrs/0005-runtime-compute-slashing"}}');var s=i(74848),r=i(28453);const o={sidebar_custom_props:{tags:void 0}},d="ADR 0004: Runtime Governance",a={},c=[{value:"Component",id:"component",level:2},{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Runtime Descriptor",id:"runtime-descriptor",level:3},{value:"Governance Model",id:"governance-model",level:4},{value:"Entity Whitelist Admission Policy",id:"entity-whitelist-admission-policy",level:4},{value:"Minimum Required Committee Election Pool Size",id:"minimum-required-committee-election-pool-size",level:4},{value:"State",id:"state",level:3},{value:"Stored Runtime Descriptors",id:"stored-runtime-descriptors",level:4},{value:"Genesis Document",id:"genesis-document",level:3},{value:"Transaction Methods",id:"transaction-methods",level:3},{value:"Register Runtime",id:"register-runtime",level:4},{value:"Messages",id:"messages",level:3},{value:"Update Runtime Descriptor",id:"update-runtime-descriptor",level:4},{value:"Consensus Parameters",id:"consensus-parameters",level:3},{value:"Registry",id:"registry",level:4},{value:"Rust Runtime Support Library",id:"rust-runtime-support-library",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"References",id:"references",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"adr-0004-runtime-governance",children:"ADR 0004: Runtime Governance"})}),"\n",(0,s.jsx)(n.h2,{id:"component",children:"Component"}),"\n",(0,s.jsx)(n.p,{children:"Oasis Core"}),"\n",(0,s.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"2020-10-07: Add per-role max node limits, minimum required election pool size"}),"\n",(0,s.jsx)(n.li,{children:"2020-09-30: Add entity whitelist admission policy max nodes limit"}),"\n",(0,s.jsx)(n.li,{children:"2020-09-17: Initial draft"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,s.jsx)(n.p,{children:"Accepted"}),"\n",(0,s.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,s.jsx)(n.p,{children:"Currently all runtimes can only be governed by a single entity -- the runtime\nowner. In this regard governance means being able to update certain fields in\nthe runtime descriptor stored by the consensus layer registry service. On one\nhand the runtime descriptor contains security-critical parameters and on the\nother there needs to be a mechanism through which the runtimes can be upgraded\n(especially so for TEE-based runtimes where a specific runtime binary is\nenforced via remote attestation mechanisms)."}),"\n",(0,s.jsxs)(n.p,{children:["This proposal extends runtime governance options and enables a path towards\nruntimes that can define their own governance mechanisms. This proposal assumes\nthat ",(0,s.jsx)(n.a,{href:"/adrs/0003-consensus-runtime-token-transfer",children:"ADR 0003"})," has been adopted and runtimes can have their own accounts in the\nstaking module."]}),"\n",(0,s.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsx)(n.p,{children:"This proposal takes a simplistic but powerful approach which allows each runtime\nto choose its governance model upon its first registration. It does so through\na newly introduced field in the runtime descriptor which indicates how the\nruntime descriptor can be updated in the future."}),"\n",(0,s.jsx)(n.h3,{id:"runtime-descriptor",children:"Runtime Descriptor"}),"\n",(0,s.jsxs)(n.p,{children:["The runtime descriptor version is bumped to ",(0,s.jsx)(n.code,{children:"2"}),". Version ",(0,s.jsx)(n.code,{children:"1"})," descriptors are\naccepted at genesis and are converted to the new format by assuming the entity\ngovernance model as that is the only option in v1. All new runtime registrations\nmust use the v2 descriptor."]}),"\n",(0,s.jsx)(n.h4,{id:"governance-model",children:"Governance Model"}),"\n",(0,s.jsx)(n.p,{children:"This proposal updates the runtime descriptor by adding fields as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-golang",children:'type Runtime struct {\n    // GovernanceModel specifies the runtime governance model.\n    GovernanceModel RuntimeGovernanceModel `json:"governance_model"`\n\n    // ... existing fields omitted ...\n}\n\n// RuntimeGovernanceModel specifies the runtime governance model.\ntype RuntimeGovernanceModel uint8\n\nconst (\n    GovernanceEntity    RuntimeGovernanceModel = 1\n    GovernanceRuntime   RuntimeGovernanceModel = 2\n    GovernanceConsensus RuntimeGovernanceModel = 3\n)\n\n// ... some text serialization methods omitted ...\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"governance_model"})," field can specifiy one of the following governance\nmodels:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["Entity governance (",(0,s.jsx)(n.code,{children:"GovernanceEntity"}),")."]})," This causes the runtime to behave\nexactly as before, the runtime owner (indicated by ",(0,s.jsx)(n.code,{children:"entity_id"})," in the runtime\ndescriptor) is the only one who can update the runtime descriptor via\n",(0,s.jsx)(n.code,{children:"registry.RegisterRuntime"})," method calls."]}),"\n",(0,s.jsx)(n.p,{children:"The runtime owner is also the one that needs to provide the required stake\nin escrow in order to avoid the runtime from being suspended. As before note\nthat anyone can delegate the required stake to the runtime owner in order to\nenable runtime operation (but the owner can always prevent the runtime from\noperating by performing actions which would cause the stake claims to no\nlonger be satisfied)."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["Runtime-defined governance (",(0,s.jsx)(n.code,{children:"GovernanceRuntime"}),")."]})," In this case the runtime\nitself is the only one who can update the runtime descriptor by emitting a\nruntime message. The runtime owner (indicated by ",(0,s.jsx)(n.code,{children:"entity_id"}),") is not able to\nperform any updates after the initial registration and such attempts must\nreturn ",(0,s.jsx)(n.code,{children:"ErrForbidden"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The runtime itself is the one that needs to provide the required stake in\nescrow in order to avoid the runtime from being suspended. This assumes that\nruntimes can have accounts in the staking module as specified by ",(0,s.jsx)(n.a,{href:"/adrs/0003-consensus-runtime-token-transfer",children:"ADR 0003"}),".\nNote that anyone can delegate the required stake to a runtime in order to\nenable its operation."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["Consensus layer governance (",(0,s.jsx)(n.code,{children:"GovernanceConsensus"}),")."]})," In this case only the\nconsensus layer itself can update the runtime descriptor either through a\nnetwork upgrade or via a consensus layer governance mechanism not specified by\nthis proposal."]}),"\n",(0,s.jsx)(n.p,{children:"Runtimes using this governance model are never suspended and do not need to\nprovide stake in escrow."}),"\n",(0,s.jsxs)(n.p,{children:["Runtimes using this governance model cannot be registered/updated via regular\nregistry method calls or runtime messages (doing so must return\n",(0,s.jsx)(n.code,{children:"ErrForbidden"}),"). Instead such a runtime can only be registered at genesis,\nthrough a network upgrade or via a consensus layer governance mechanism not\nspecified by this proposal."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"entity-whitelist-admission-policy",children:"Entity Whitelist Admission Policy"}),"\n",(0,s.jsx)(n.p,{children:"The entity whitelist admission policy configuration structure is changed to\nallow specifying the maximum number of nodes that each entity can register under\nthe given runtime for each role."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-golang",children:'type EntityWhitelistConfig struct {\n    // MaxNodes is the maximum number of nodes that an entity can register under\n    // the given runtime for a specific role. If the map is empty or absent, the\n    // number of nodes is unlimited. If the map is present and non-empty, the\n    // the number of nodes is restricted to the specified maximum (where zero\n    // means no nodes allowed), any missing roles imply zero nodes.\n    MaxNodes map[node.RolesMask]uint16 `json:"max_nodes,omitempty"`\n}\n\ntype EntityWhitelistRuntimeAdmissionPolicy struct {\n    Entities map[signature.PublicKey]EntityWhitelistConfig `json:"entities"`\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The new ",(0,s.jsx)(n.code,{children:"max_nodes"})," field specifies the maximum number of nodes an entity can\nregister for the given runtime for each role. If the map is empty or absent, the\nnumber of nodes is unlimited. If the map is present and non-empty, the number of\nnodes is restricted to the specified number (where zero means no nodes are\nallowed). Any missing roles imply zero nodes."]}),"\n",(0,s.jsxs)(n.p,{children:["Each key (roles mask) in the ",(0,s.jsx)(n.code,{children:"max_nodes"})," map must specify a single role,\notherwise the runtime descriptor is rejected with ",(0,s.jsx)(n.code,{children:"ErrInvalidArgument"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When transforming runtime descriptors from version 1, an entry in the ",(0,s.jsx)(n.code,{children:"entities"}),"\nfield maps to an ",(0,s.jsx)(n.code,{children:"EntityWhitelistConfig"})," structure with ",(0,s.jsx)(n.code,{children:"max_nodes"})," absent,\ndenoting that an unlimited number of nodes is allowed (as before)."]}),"\n",(0,s.jsx)(n.h4,{id:"minimum-required-committee-election-pool-size",children:"Minimum Required Committee Election Pool Size"}),"\n",(0,s.jsx)(n.p,{children:"The executor and storage runtime parameters are updated to add a new field\ndefining the minimum required committee election pool size. The committee\nscheduler is updated to refuse election for a given runtime committee in case\nthe number of candidate nodes is less than the configured minimum pool size."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-golang",children:'type ExecutorParameters struct {\n    // MinPoolSize is the minimum required candidate compute node pool size.\n    MinPoolSize uint64 `json:"min_pool_size"`\n\n    // ... existing fields omitted ...\n}\n\ntype StorageParameters struct {\n    // MinPoolSize is the minimum required candidate storage node pool size.\n    MinPoolSize uint64 `json:"min_pool_size"`\n\n    // ... existing fields omitted ...\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The value of ",(0,s.jsx)(n.code,{children:"min_pool_size"})," must be non-zero and must be equal to or greater\nthan the corresponding sum of ",(0,s.jsx)(n.code,{children:"group_size"})," and ",(0,s.jsx)(n.code,{children:"group_backup_size"}),". Otherwise\nthe runtime descriptor is rejected with ",(0,s.jsx)(n.code,{children:"ErrInvalidArgument"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When transforming runtime descriptors from version 1, ",(0,s.jsx)(n.code,{children:"min_pool_size"})," for the\nexecutor committee is computed as ",(0,s.jsx)(n.code,{children:"group_size + group_backup_size"})," while the\n",(0,s.jsx)(n.code,{children:"min_pool_size"})," for the storage committee is equal to ",(0,s.jsx)(n.code,{children:"group_size"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"state",children:"State"}),"\n",(0,s.jsx)(n.p,{children:"This proposal introduces/updates the following consensus state in the registry\nmodule:"}),"\n",(0,s.jsx)(n.h4,{id:"stored-runtime-descriptors",children:"Stored Runtime Descriptors"}),"\n",(0,s.jsxs)(n.p,{children:["Since the runtime descriptors can now be updated by actors other than the\ninitial registering entity, it does not make sense to store signed runtime\ndescriptors. The value of storage key prefixed with ",(0,s.jsx)(n.code,{children:"0x13"})," which previously\ncontained signed runtime descriptors is modified to store plain runtime\ndescriptors."]}),"\n",(0,s.jsx)(n.h3,{id:"genesis-document",children:"Genesis Document"}),"\n",(0,s.jsx)(n.p,{children:"This proposal updates the registry part of the genesis document as follows:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The type of the ",(0,s.jsx)(n.code,{children:"runtimes"})," field is changed to a list of runtime descriptors\n(was a list of ",(0,s.jsx)(n.em,{children:"signed"})," runtime descriptors before)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The type of the ",(0,s.jsx)(n.code,{children:"suspended_runtimes"})," field is changed to a list of runtime\ndescriptors (was a list of ",(0,s.jsx)(n.em,{children:"signed"})," runtime descriptors before)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Runtime descriptors must be transformed to support the new fields."}),"\n",(0,s.jsx)(n.h3,{id:"transaction-methods",children:"Transaction Methods"}),"\n",(0,s.jsx)(n.p,{children:"This proposal updates the following transaction methods in the registry module:"}),"\n",(0,s.jsx)(n.h4,{id:"register-runtime",children:"Register Runtime"}),"\n",(0,s.jsx)(n.p,{children:"Runtime registration enables a new runtime to be created or an existing runtime\nto be updated (in case the governance model allows it)."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Method name:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"registry.RegisterRuntime\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The body of a register runtime transaction must be a ",(0,s.jsx)(n.code,{children:"Runtime"})," descriptor.\nThe signer of the transaction must be the owning entity key."]}),"\n",(0,s.jsx)(n.p,{children:"Registering a runtime may require sufficient stake in either the owning entity's\n(when entity governance is used) or the runtime's (when runtime governance is\nused) escrow account."}),"\n",(0,s.jsxs)(n.p,{children:["Changing the governance model from ",(0,s.jsx)(n.code,{children:"GovernanceEntity"})," to ",(0,s.jsx)(n.code,{children:"GovernanceRuntime"})," is\nallowed. Any other governance model changes are not allowed and must fail with\n",(0,s.jsx)(n.code,{children:"ErrForbidden"}),". Support for other changes is deferred to a consensus layer\ngovernance mechanism not specified by this proposal."]}),"\n",(0,s.jsxs)(n.p,{children:["Using the ",(0,s.jsx)(n.code,{children:"GovernanceRuntime"})," governance model for a runtime of any kind other\nthan ",(0,s.jsx)(n.code,{children:"KindCompute"})," must return ",(0,s.jsx)(n.code,{children:"ErrInvalidArgument"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"messages",children:"Messages"}),"\n",(0,s.jsx)(n.p,{children:"This proposal introduces the following runtime messages:"}),"\n",(0,s.jsx)(n.h4,{id:"update-runtime-descriptor",children:"Update Runtime Descriptor"}),"\n",(0,s.jsx)(n.p,{children:"The update runtime descriptor message enables a runtime to update its own\ndescriptor when the current governance model allows it."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Field name:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"update_runtime\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Body:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-golang",children:"type UpdateRuntimeMessage struct {\n    registry.Runtime\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The body of the update runtime descriptor message is a new runtime descriptor\nthat must be for the runtime emitting this message. Otherwise the message is\nconsidered malformed."}),"\n",(0,s.jsxs)(n.p,{children:["The actions performed when processing the message are the same as those\nperformed when processing the ",(0,s.jsx)(n.code,{children:"registry.RegisterRuntime"})," method call, just made\non the runtime's (instead of an entity's) behalf."]}),"\n",(0,s.jsx)(n.h3,{id:"consensus-parameters",children:"Consensus Parameters"}),"\n",(0,s.jsx)(n.h4,{id:"registry",children:"Registry"}),"\n",(0,s.jsx)(n.p,{children:"This proposal introduces the following new consensus parameters in the registry\nmodule:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enable_runtime_governance_models"})," (set of ",(0,s.jsx)(n.code,{children:"RuntimeGovernanceModel"}),") specifies\nthe set of runtime governance models that are allowed to be used when\ncreating/updating registrations (either via method calls or via runtime\nmessages). In case a runtime is using a governance model not specified in this\nlist, an update to such a runtime must fail with ",(0,s.jsx)(n.code,{children:"ErrForbidden"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"rust-runtime-support-library",children:"Rust Runtime Support Library"}),"\n",(0,s.jsxs)(n.p,{children:["The Rust runtime support library (",(0,s.jsx)(n.code,{children:"oasis-core-runtime"}),") must be updated to\nsupport the updated and newly needed message structures (the runtime descriptor\nand the update runtime message)."]}),"\n",(0,s.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Runtimes can define their governance model, enabling them to become more\ndecentralized while still allowing upgrades."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Runtimes using the entity whitelist admission policy can limit the number of\nnodes that each entity can register."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Runtimes can specify the minimum size of the compute/storage node pool from\nwhich committees are elected."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,s.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/adrs/0003-consensus-runtime-token-transfer",children:"ADR 0003"})," - Consensus/Runtime Token Transfer"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>d});var t=i(96540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);