"use strict";(globalThis.webpackChunkdocs_oasis_io=globalThis.webpackChunkdocs_oasis_io||[]).push([[8113],{4150:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"core/runtime/README","title":"Runtime Layer","description":"Runtime Layer","source":"@site/docs/core/runtime/README.md","sourceDirName":"core/runtime","slug":"/core/runtime/","permalink":"/core/runtime/","draft":false,"unlisted":false,"editUrl":"https://github.com/oasisprotocol/oasis-core/edit/stable/24.2.x/docs/runtime/README.md","tags":[],"version":"current","lastUpdatedAt":1757571245000,"frontMatter":{"sidebar_custom_props":{}},"sidebar":"oasisCore","previous":{"title":"Transaction Test Vectors","permalink":"/core/consensus/test-vectors"},"next":{"title":"Runtime Host Protocol","permalink":"/core/runtime/runtime-host-protocol"}}');var i=t(74848),r=t(28453);const o={sidebar_custom_props:{tags:void 0}},a="Runtime Layer",c={},l=[{value:"Runtimes",id:"runtimes",level:2},{value:"Operation Model",id:"operation-model",level:2},{value:"Discrepancy Detection and Resolution",id:"discrepancy-detection-and-resolution",level:3},{value:"Compute Committee Roles and Commitments",id:"compute-committee-roles-and-commitments",level:3},{value:"Storage Receipts",id:"storage-receipts",level:3},{value:"Suspending Runtimes",id:"suspending-runtimes",level:3},{value:"Emitting Messages",id:"emitting-messages",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"runtime-layer",children:"Runtime Layer"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Runtime Layer",src:t(64149).A+""})}),"\n",(0,i.jsxs)(n.p,{children:["The Oasis Core runtime layer enables independent ",(0,i.jsx)(n.em,{children:"runtimes"})," to schedule and\nexecute stateful computations and commit result summaries to the\n",(0,i.jsx)(n.a,{href:"/core/consensus/",children:"consensus layer"}),". In addition to ",(0,i.jsx)(n.a,{href:"/core/consensus/services/roothash",children:"verifying and storing"})," the canonical runtime\nstate summaries the ",(0,i.jsx)(n.a,{href:"/core/consensus/",children:"consensus layer"})," also serves as the ",(0,i.jsx)(n.a,{href:"/core/consensus/services/registry",children:"registry"})," for node and\nruntime metadata, a ",(0,i.jsx)(n.a,{href:"/core/consensus/services/scheduler",children:"scheduler"})," that elects runtime compute committees and a\ncoordinator for ",(0,i.jsx)(n.a,{href:"/core/consensus/services/keymanager",children:"key manager replication"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"runtimes",children:"Runtimes"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.em,{children:"runtime"})," is effectively a replicated application with shared state. The\napplication can receive transactions from clients and based on those it can\nperform arbitrary state mutations. This replicated state and application logic\nexists completely separate from the consensus layer state and logic, but it\nleverages the same consensus layer for finality with the consensus layer\nproviding the source of canonical state. Multiple runtimes can share the same\nconsensus layer."]}),"\n",(0,i.jsxs)(n.p,{children:["In Oasis Core a runtime can be any executable that speaks the\n",(0,i.jsx)(n.a,{href:"/core/runtime/runtime-host-protocol",children:"Runtime Host Protocol"})," which is used to communicate between a runtime and an\nOasis Core Node. The executable usually runs in a sandboxed environment with\nthe only external interface being the Runtime Host Protocol. The execution\nenvironment currently includes a sandbox based on Linux namespaces and SECCOMP\noptionally combined with Intel SGX enclaves for confidential computation."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Runtime Execution",src:t(31029).A+""})}),"\n",(0,i.jsx)(n.p,{children:"In the future this may be expanded with supporting running each runtime in its\nown virtual machine and with other confidential computing technologies."}),"\n",(0,i.jsx)(n.h2,{id:"operation-model",children:"Operation Model"}),"\n",(0,i.jsxs)(n.p,{children:["The relationship between ",(0,i.jsx)(n.a,{href:"/core/consensus/",children:"consensus layer services"}),' and runtime services is best\ndescribed by a simple example of a "Runtime A" that is created and receives\ntransactions from clients (also see the figure above for an overview).']}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The runtime first needs to be created. In addition to developing code that\nwill run in the runtime itself, we also need to specify some metadata related\nto runtime operation, including a unique ",(0,i.jsx)(n.a,{href:"/core/runtime/identifiers",children:"runtime identifier"}),", and then\n",(0,i.jsx)(n.a,{href:"/core/consensus/services/registry#register-runtime",children:"register the runtime"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"We also need some nodes that will actually run the runtime executable and\nprocess any transactions from clients (compute nodes). These nodes currently\nneed to have the executable available locally and must be configured as\ncompute nodes."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"In addition to compute nodes a runtime also needs storage nodes to store its\nstate."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Both kinds of ",(0,i.jsx)(n.a,{href:"/core/consensus/services/registry#register-node",children:"nodes will register"})," on the consensus layer announcing their\nwillingness to participate in the operation of Runtime A."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["After an ",(0,i.jsx)(n.a,{href:"/core/consensus/services/epochtime",children:"epoch transition"})," the ",(0,i.jsx)(n.a,{href:"/core/consensus/services/scheduler",children:"committee scheduler"})," service will elect\nregistered compute and storage nodes into different committees based on role.\nElections are randomized based on entropy provided by the ",(0,i.jsx)(n.a,{href:"/core/consensus/services/beacon",children:"random beacon"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["A client may submit transactions by querying the consensus layer to get the\ncurrent executor committee for a given runtime, connect to it, publish\ntransactions and wait for finalization by the consensus layer. In order to\nmake it easier to write clients, the Oasis Node exposes a runtime\n",(0,i.jsx)(n.a,{href:"/core/oasis-node/rpc",children:"client RPC API"})," that encapsulates all this functionality in a ",(0,i.jsx)(n.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/runtime/client/api?tab=doc#RuntimeClient.SubmitTx",children:(0,i.jsx)(n.code,{children:"SubmitTx"})}),"\ncall."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The transactions are batched and proceed through the transaction processing\npipeline. At the end, results are persisted to storage and the\n",(0,i.jsx)(n.a,{href:"/core/consensus/services/roothash",children:"roothash service"})," in the consensus layer finalizes state after verifying\nthat computation was performed correctly and state was correctly persisted."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The compute nodes are ready to accept the next batch and the process can\nrepeat from step 6."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Note that the above example describes the ",(0,i.jsx)(n.em,{children:"happy path"}),", a scenario where there\nare no failures. Described steps mention things like verifying that computation\nwas performed ",(0,i.jsx)(n.em,{children:"correctly"})," and that state was ",(0,i.jsx)(n.em,{children:"correctly stored"}),". How does the\nconsensus layer actually know that?"]}),"\n",(0,i.jsx)(n.h3,{id:"discrepancy-detection-and-resolution",children:"Discrepancy Detection and Resolution"}),"\n",(0,i.jsx)(n.p,{children:"The key idea behind ensuring integrity of runtime computations is replicated\ncomputation with discrepancy detection. This basically means that any\ncomputation (e.g., execution of a transaction) is replicated among multiple\ncompute nodes. They all execute the exact same functions and produce results,\nwhich must all match. If they don't (e.g., if even a single node produces\ndifferent results), this is treated as a discrepancy."}),"\n",(0,i.jsx)(n.p,{children:"In case of a discrepancy, the computation must be repeated using a separate\nlarger compute committee which decides what the correct results were. Since all\ncommitments are attributable to compute nodes, any node(s) that produced\nincorrect results may be subject to having their stake slashed and may be\nremoved from future committees."}),"\n",(0,i.jsx)(n.p,{children:"Given the above, an additional constraint with replicated runtimes is that they\nmust be fully deterministic, meaning that a computation operating on the same\ninitial state executing the same inputs (transactions) must always produce the\nsame outputs and new state. In case a runtime's execution exhibits\nnon-determinism this will manifest itself as discrepancies since nodes will\nderive different results when replicating computation."}),"\n",(0,i.jsx)(n.h3,{id:"compute-committee-roles-and-commitments",children:"Compute Committee Roles and Commitments"}),"\n",(0,i.jsx)(n.p,{children:"A compute node can be elected into an executor committee and may have one of the\nfollowing roles:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Primary executor node. At any given round a single node is selected among all\nthe primary executor nodes to be a ",(0,i.jsx)(n.em,{children:"transaction scheduler node"})," (roughly equal\nto the role of a ",(0,i.jsx)(n.em,{children:"block proposer"}),")."]}),"\n",(0,i.jsx)(n.li,{children:"Backup executor node. Backup nodes can be activated by the consensus layer in\ncase it determines that there is a discrepancy."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The size of the primary and backup executor committees, together with other\nrelated parameters, can be configured on a per-runtime basis. The ",(0,i.jsx)(n.em,{children:"primary"}),"\nnodes are the ones that will batch incoming transactions into blocks and execute\nthe state transitions to derive the new state root. They perform this in a\nreplicated fashion where all the primary executor nodes execute the same inputs\n(transactions) on the same initial state."]}),"\n",(0,i.jsxs)(n.p,{children:["After execution they will sign ",(0,i.jsx)(n.a,{href:"https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/roothash/api/commitment?tab=doc",children:"cryptographic commitments"})," specifying the\ninputs, the initial state, the outputs and the resulting state. In case\ncomputation happens inside a trusted execution environment (TEE) like Intel SGX,\nthe commitment will also include a platform attestation proving that the\ncomputation took place in a given TEE."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"/core/consensus/services/roothash",children:"roothash service"})," in the consensus layer will collect commitments and\nverify that all nodes have indeed computed the same result. As mentioned in case\nof discrepancies it will instruct nodes elected as ",(0,i.jsx)(n.em,{children:"backups"})," to repeat the\ncomputation."]}),"\n",(0,i.jsx)(n.h3,{id:"storage-receipts",children:"Storage Receipts"}),"\n",(0,i.jsxs)(n.p,{children:["All runtime persistent state is stored by storage nodes. These provide a\n",(0,i.jsx)(n.a,{href:"/core/mkvs",children:"Merklized Key-Value Store (MKVS)"})," to compute nodes. The MKVS stores immutable\nstate cryptographically summarized by a single root hash. When a storage node\nstores a given state update, it signs a receipt stating that it is storing a\nspecific root. These receipts are verified by the ",(0,i.jsx)(n.a,{href:"/core/consensus/services/roothash",children:"roothash service"})," before\naccepting a commitment from a compute node."]}),"\n",(0,i.jsx)(n.h3,{id:"suspending-runtimes",children:"Suspending Runtimes"}),"\n",(0,i.jsx)(n.p,{children:"Since periodic maintenance work must be performed on each epoch transition\n(e.g., electing runtime committees), fees for that maintenance are paid by any\nnodes that register to perform work for a specific runtime. Fees are pre-paid\nfor the number of epochs a node registers for. If there are no committees for a\nruntime on epoch transition, the runtime is suspended for the epoch.\nThe runtime is also suspended in case the registering entity no longer has\nenough stake to cover the entity and runtime deposits. The runtime will be\nresumed on the epoch transition if runtime nodes will register and the\nregistering entity will have enough stake."}),"\n",(0,i.jsx)(n.h3,{id:"emitting-messages",children:"Emitting Messages"}),"\n",(0,i.jsxs)(n.p,{children:["Runtimes may ",(0,i.jsx)(n.a,{href:"/core/runtime/messages",children:"emit messages"})," to instruct the consensus layer what to do on their\nbehalf. This makes it possible for runtimes to ",(0,i.jsx)(n.a,{href:"/core/consensus/services/staking#runtime-accounts",children:"own staking accounts"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(96540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},31029:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/oasis-core-runtime-execution-502d059c83dd21c3135c993c339f9240.svg"},64149:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/oasis-core-runtime-details-acaba7d29c87a75333e050c8fe4d07ae.svg"}}]);