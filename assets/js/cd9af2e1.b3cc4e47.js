"use strict";(globalThis.webpackChunkdocs_oasis_io=globalThis.webpackChunkdocs_oasis_io||[]).push([[1198],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var t=s(96540);const i={},r=t.createContext(i);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},77757:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"core/consensus/test-vectors","title":"Transaction Test Vectors","description":"In order to test transaction generation, parsing and signing, we provide a set","source":"@site/docs/core/consensus/test-vectors.md","sourceDirName":"core/consensus","slug":"/core/consensus/test-vectors","permalink":"/core/consensus/test-vectors","draft":false,"unlisted":false,"editUrl":"https://github.com/oasisprotocol/oasis-core/edit/stable/24.2.x/docs/consensus/test-vectors.md","tags":[],"version":"current","lastUpdatedAt":1757571245000,"frontMatter":{"sidebar_custom_props":{}},"sidebar":"oasisCore","previous":{"title":"Genesis Document","permalink":"/core/consensus/genesis"},"next":{"title":"Runtime Layer","permalink":"/core/runtime/"}}');var i=s(74848),r=s(28453);const o={sidebar_custom_props:{tags:void 0}},c="Transaction Test Vectors",a={},d=[{value:"Structure",id:"structure",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"transaction-test-vectors",children:"Transaction Test Vectors"})}),"\n",(0,i.jsx)(n.p,{children:"In order to test transaction generation, parsing and signing, we provide a set\nof test vectors. They can be generated for the following consensus services:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/core/consensus/services/staking#test-vectors",children:"Staking"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/core/consensus/services/registry#test-vectors",children:"Registry"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/core/consensus/services/governance#test-vectors",children:"Governance"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"structure",children:"Structure"}),"\n",(0,i.jsx)(n.p,{children:"The generated test vectors file is a JSON document which provides an array of\nobjects (test vectors). Each test vector has the following fields:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"kind"})," is a human-readable string describing what kind of a transaction the\ngiven test vector is describing (e.g., ",(0,i.jsx)(n.code,{children:'"Transfer"'}),")."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"signature_context"})," is the ",(0,i.jsx)(n.a,{href:"/core/crypto#domain-separation",children:"domain separation context"})," used for signing the\ntransaction."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tx"})," is the human-readable ",(0,i.jsx)(n.em,{children:"interpreted"})," unsigned transaction. Its purpose is\nto make it easier for the implementer to understand what the content of the\ntransaction is. ",(0,i.jsxs)(n.strong,{children:["It does not contain the structure that can be serialized\ndirectly (e.g., [addresses] may be represented as Bech32-encoded strings while\nin the ",(0,i.jsx)(n.a,{href:"/core/encoding",children:"encoded"})," transaction, these would be binary blobs)."]})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"signed_tx"})," is the human-readable signed transaction to make it easier for the\nimplementer to understand how the ",(0,i.jsx)(n.a,{href:"/core/crypto#envelopes",children:"signature envelope"})," looks like."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"encoded_tx"})," is the CBOR-encoded (since test vectors are in JSON and CBOR\nencoding is a binary encoding it also needs to be Base64-encoded) unsigned\ntransaction."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"encoded_signed_tx"})," is the CBOR-encoded (since test vectors are in JSON and\nCBOR encoding is a binary encoding it also needs to be Base64-encoded) signed\ntransaction. ",(0,i.jsx)(n.strong,{children:"This is what is actually broadcast to the network."})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"valid"})," is a boolean flag indicating whether the given test vector represents\na valid transaction, including:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"transaction having a valid signature,"}),"\n",(0,i.jsx)(n.li,{children:"transaction being correctly serialized,"}),"\n",(0,i.jsx)(n.li,{children:"transaction passing basic static validation."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["NOTE: Even if a transaction passes basic static validation, it may still\n",(0,i.jsx)(n.strong,{children:"not"})," be a valid transaction on the given network due to invalid nonce, or\ndue to some specific parameters set on the network."]})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"signer_private_key"})," is the Ed25519 private key that was used to sign the\ntransaction in the test vector."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"signer_public_key"})," is the Ed25519 public key corresponding to\n",(0,i.jsx)(n.code,{children:"signer_private_key"}),"."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);