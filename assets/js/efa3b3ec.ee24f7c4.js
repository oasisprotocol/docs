"use strict";(globalThis.webpackChunkdocs_oasis_io=globalThis.webpackChunkdocs_oasis_io||[]).push([[3035],{15441:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"build/tools/other-paratimes/cipher/confidential-smart-contract","title":"Confidential Hello World","description":"Confidential smart contract execution on Oasis is assured by three mechanisms:","source":"@site/docs/build/tools/other-paratimes/cipher/confidential-smart-contract.md","sourceDirName":"build/tools/other-paratimes/cipher","slug":"/build/tools/other-paratimes/cipher/confidential-smart-contract","permalink":"/build/tools/other-paratimes/cipher/confidential-smart-contract","draft":false,"unlisted":false,"editUrl":"https://github.com/oasisprotocol/oasis-sdk/edit/main/docs/contract/confidential-smart-contract.md","tags":[],"version":"current","lastUpdatedAt":1761867754000,"frontMatter":{"sidebar_custom_props":{}},"sidebar":"developers","previous":{"title":"Hello World","permalink":"/build/tools/other-paratimes/cipher/hello-world"},"next":{"title":"Emerald ParaTime","permalink":"/build/tools/other-paratimes/emerald/"}}');var a=n(74848),s=n(28453);const r={sidebar_custom_props:{tags:void 0}},i="Confidential Hello World",c={},l=[{value:"Confidential cell",id:"confidential-cell",level:2},{value:"Confidential Instantiation and Calling",id:"confidential-instantiation-and-calling",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"confidential-hello-world",children:"Confidential Hello World"})}),"\n",(0,a.jsx)(t.p,{children:"Confidential smart contract execution on Oasis is assured by three mechanisms:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"the contract is executed in a trusted execution environment,"}),"\n",(0,a.jsx)(t.li,{children:"the contract's storage on the blockchain is encrypted,"}),"\n",(0,a.jsx)(t.li,{children:"the client's transactions and queries are end-to-end encrypted."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The first mechanism is implemented as part of the ParaTime attestation process\non the consensus layer and is opaque to the dApp developer."}),"\n",(0,a.jsx)(t.p,{children:"The other two mechanisms are available to dApp developers. The remainder of\nthis chapter will show you how to use an encrypted contract storage\nand perform contract operations with end-to-end encryption on Cipher."}),"\n",(0,a.jsx)(t.h2,{id:"confidential-cell",children:"Confidential cell"}),"\n",(0,a.jsxs)(t.p,{children:["In the ",(0,a.jsx)(t.a,{href:"/build/tools/other-paratimes/cipher/hello-world",children:"hello world"})," example we used\n",(0,a.jsx)(t.a,{href:"https://api.docs.oasis.io/oasis-sdk/oasis_contract_sdk_storage/cell/struct.PublicCell.html",children:(0,a.jsx)(t.code,{children:"PublicCell<T>"})})," to access the key-value store\nof that contract instance. In this case the value was stored unencrypted on the\nblockchain associated with the hash of the key we provided to the constructor\n(e.g., the ",(0,a.jsx)(t.code,{children:"counter"})," in ",(0,a.jsx)(t.code,{children:'PublicCell::new(b"counter")'}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["Cipher supports another primitive ",(0,a.jsx)(t.a,{href:"https://api.docs.oasis.io/oasis-sdk/oasis_contract_sdk_storage/cell/struct.ConfidentialCell.html",children:(0,a.jsx)(t.code,{children:"ConfidentialCell<T>"})}),"\nwhich enables you to store and load data confidentially assured by\nhardware-level encryption. In addition, the value is encrypted along with a\nnonce so that it appears different each time to the blockchain observer, even\nif the decrypted value remains equal. Namely, the nonce is generated from:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"the round number,"}),"\n",(0,a.jsx)(t.li,{children:"the number of the sub-call during current smart contract execution,"}),"\n",(0,a.jsx)(t.li,{children:"the number of confidential storage accesses from smart contracts in the\ncurrent block."}),"\n"]}),"\n",(0,a.jsx)(t.admonition,{type:"danger",children:(0,a.jsxs)(t.p,{children:["The location of the confidential cell inside the contract state is\n",(0,a.jsx)(t.strong,{children:"still based on the initialization key passed to the constructor"}),".\nConsequently, if you declare a number of confidential cells and write to the\nsame one on each call, the blockchain observers will notice that the same\ncell is being changed every time."]})}),"\n",(0,a.jsxs)(t.p,{children:["To call the confidential cell getter and setter, you will need to provide the\ninstance of the ",(0,a.jsx)(t.em,{children:"confidential store"}),". The store is obtained by calling\n",(0,a.jsx)(t.code,{children:"confidential_store()"})," on the contract's ",(0,a.jsx)(t.em,{children:"context"})," object. If, for example, the\nnode operator will try to execute your code in a non-confidential environment,\nthey would not obtain the keys required to perform decryption so the operation\nwould fail."]}),"\n",(0,a.jsx)(t.p,{children:"Now, let's look at how a confidential version of the hello world smart contract\nwould look like:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",metastring:'title="src/lib.rs"',children:'//! A confidential hello world smart contract.\nextern crate alloc;\n\nuse oasis_contract_sdk as sdk;\nuse oasis_contract_sdk_storage::cell::ConfidentialCell;\n\n/// All possible errors that can be returned by the contract.\n///\n/// Each error is a triplet of (module, code, message) which allows it to be both easily\n/// human readable and also identifyable programmatically.\n#[derive(Debug, thiserror::Error, sdk::Error)]\npub enum Error {\n    #[error("bad request")]\n    #[sdk_error(code = 1)]\n    BadRequest,\n}\n\n/// All possible requests that the contract can handle.\n///\n/// This includes both calls and queries.\n#[derive(Clone, Debug, cbor::Encode, cbor::Decode)]\npub enum Request {\n    #[cbor(rename = "instantiate")]\n    Instantiate { initial_counter: u64 },\n\n    #[cbor(rename = "say_hello")]\n    SayHello { who: String },\n}\n\n/// All possible responses that the contract can return.\n///\n/// This includes both calls and queries.\n#[derive(Clone, Debug, Eq, PartialEq, cbor::Encode, cbor::Decode)]\npub enum Response {\n    #[cbor(rename = "hello")]\n    Hello { greeting: String },\n\n    #[cbor(rename = "empty")]\n    Empty,\n}\n\n/// The contract type.\npub struct HelloWorld;\n\n/// Storage cell for the counter.\nconst COUNTER: ConfidentialCell<u64> = ConfidentialCell::new(b"counter");\n\nimpl HelloWorld {\n    /// Increment the counter and return the previous value.\n    fn increment_counter<C: sdk::Context>(ctx: &mut C) -> u64 {\n        let counter = COUNTER.get(ctx.confidential_store()).unwrap_or_default();\n        COUNTER.set(ctx.confidential_store(), counter + 1);\n\n        counter\n    }\n}\n\n// Implementation of the sdk::Contract trait is required in order for the type to be a contract.\nimpl sdk::Contract for HelloWorld {\n    type Request = Request;\n    type Response = Response;\n    type Error = Error;\n\n    fn instantiate<C: sdk::Context>(ctx: &mut C, request: Request) -> Result<(), Error> {\n        // This method is called during the contracts.Instantiate call when the contract is first\n        // instantiated. It can be used to initialize the contract state.\n        match request {\n            // We require the caller to always pass the Instantiate request.\n            Request::Instantiate { initial_counter } => {\n                // Initialize counter to specified value.\n                COUNTER.set(ctx.confidential_store(), initial_counter);\n\n                Ok(())\n            }\n            _ => Err(Error::BadRequest),\n        }\n    }\n\n    fn call<C: sdk::Context>(ctx: &mut C, request: Request) -> Result<Response, Error> {\n        // This method is called for each contracts.Call call. It is supposed to handle the request\n        // and return a response.\n        match request {\n            Request::SayHello { who } => {\n                // Increment the counter and retrieve the previous value.\n                let counter = Self::increment_counter(ctx);\n\n                // Return the greeting as a response.\n                Ok(Response::Hello {\n                    greeting: format!("hello {who} ({counter})"),\n                })\n            }\n            _ => Err(Error::BadRequest),\n        }\n    }\n\n    fn query<C: sdk::Context>(_ctx: &mut C, _request: Request) -> Result<Response, Error> {\n        // This method is called for each contracts.Query query. It is supposed to handle the\n        // request and return a response.\n        Err(Error::BadRequest)\n    }\n}\n\n// Create the required Wasm exports required for the contract to be runnable.\nsdk::create_contract!(HelloWorld);\n\n// We define some simple contract tests below.\n#[cfg(test)]\nmod test {\n    use oasis_contract_sdk::{testing::MockContext, types::ExecutionContext, Contract};\n\n    use super::*;\n\n    #[test]\n    fn test_hello() {\n        // Create a mock execution context with default values.\n        let mut ctx: MockContext = ExecutionContext::default().into();\n\n        // Instantiate the contract.\n        HelloWorld::instantiate(\n            &mut ctx,\n            Request::Instantiate {\n                initial_counter: 11,\n            },\n        )\n        .expect("instantiation should work");\n\n        // Dispatch the SayHello message.\n        let rsp = HelloWorld::call(\n            &mut ctx,\n            Request::SayHello {\n                who: "unit test".to_string(),\n            },\n        )\n        .expect("SayHello call should work");\n\n        // Make sure the greeting is correct.\n        assert_eq!(\n            rsp,\n            Response::Hello {\n                greeting: "hello unit test (11)".to_string()\n            }\n        );\n\n        // Dispatch another SayHello message.\n        let rsp = HelloWorld::call(\n            &mut ctx,\n            Request::SayHello {\n                who: "second call".to_string(),\n            },\n        )\n        .expect("SayHello call should work");\n\n        // Make sure the greeting is correct.\n        assert_eq!(\n            rsp,\n            Response::Hello {\n                greeting: "hello second call (12)".to_string()\n            }\n        );\n    }\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"The contract is built the same way as its non-confidential counterpart:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:"cargo build --target wasm32-unknown-unknown --release\n"})}),"\n",(0,a.jsx)(t.admonition,{type:"caution",children:(0,a.jsxs)(t.p,{children:["The blockchain store containing all compiled contracts is public. This means\nthat anyone will be able to decompile your smart contract and see how it\nworks. ",(0,a.jsx)(t.strong,{children:"Do not put any sensitive data inside the smart contract code!"})]})}),"\n",(0,a.jsx)(t.p,{children:"Since the smart contracts store is public, uploading the Wasm code is\nthe same as for the non-confidential ones:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:"oasis contract upload hello_world.wasm\n"})}),"\n",(0,a.jsx)(t.h2,{id:"confidential-instantiation-and-calling",children:"Confidential Instantiation and Calling"}),"\n",(0,a.jsxs)(t.p,{children:["To generate an encrypted transaction, the ",(0,a.jsx)(t.code,{children:"oasis contract"})," subcommand\nexpects a ",(0,a.jsx)(t.code,{children:"--encrypted"})," flag. The client (",(0,a.jsx)(t.code,{children:"oasis"})," command in our case) will\ngenerate and use an ephemeral keypair for encryption. If the original\ntransaction was encrypted, the returned transaction result will also be\nencrypted inside the trusted execution environment to prevent a\nman-in-the-middle attack by the compute node."]}),"\n",(0,a.jsx)(t.p,{children:"Encrypted transactions have the following encrypted fields:\ncontract address, function name, parameters and the amounts and types of tokens\nsent."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Encrypted transactions are not anonymous!"})," Namely, the transaction contains\nunencrypted public key of your account or a list of expected multisig keys,\nthe gas limit and the amount of fee paid for the transaction execution."]}),"\n",(0,a.jsx)(t.admonition,{type:"danger",children:(0,a.jsx)(t.p,{children:"While the transaction execution is confidential, its effects may reveal some\ninformation. For example, the account balances are public. If the effect is,\nsay, subtraction of 10 tokens from the signer's account, this most probably\nimplies that they have been transferred as part of this transaction."})}),"\n",(0,a.jsxs)(t.p,{children:["Before we instantiate the contract we need to consider the gas usage of our\nconfidential smart contract. Since the execution of the smart contract is\ndependent on the (confidential) smart contract state, the gas limit cannot be\ncomputed automatically. Currently, the gas limit for confidential transactions\nis tailored towards simple transaction execution (e.g. no gas is reserved for\naccessing the contract state). For more expensive transactions, we\nneed to explicitly pass the ",(0,a.jsx)(t.code,{children:"--gas-limit"})," parameter and ",(0,a.jsx)(t.em,{children:"guess"})," the sufficient\nvalue for now or we will get the ",(0,a.jsx)(t.code,{children:"out of gas"})," error. For example, to\ninstantiate our smart contract above with a single write to the contract state,\nwe need to raise the gas limit to ",(0,a.jsx)(t.code,{children:"60000"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:"oasis contract instantiate CODEID '{instantiate: {initial_counter: 42}}' --encrypted --gas-limit 400000\n"})}),"\n",(0,a.jsxs)(t.admonition,{type:"danger",children:[(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"out of gas"})," error can ",(0,a.jsx)(t.strong,{children:"potentially reveal the (confidential) state of the\nsmart contract"}),"! If your smart contract contains a branch which depends on the\nvalue stored in the contract state, an attack similar to the ",(0,a.jsx)(t.strong,{children:"timing attack"}),"\nknown from the design of cryptographic algorithms can succeed. To overcome this,\nyour code should ",(0,a.jsx)(t.strong,{children:"never contain branches depending on secret smart contract\nstate"}),"."]}),(0,a.jsxs)(t.p,{children:["A similar gas limit attack could reveal the ",(0,a.jsx)(t.strong,{children:"client's transaction parameters"}),".\nFor example, if calling function ",(0,a.jsx)(t.code,{children:"A"})," costs ",(0,a.jsx)(t.code,{children:"50,000"})," gas units and function ",(0,a.jsx)(t.code,{children:"B"}),"\n",(0,a.jsx)(t.code,{children:"300,000"})," gas units, the attacker could imply which function call was performed\nbased on the transaction's gas limit, which is public. To mitigate this attack,\nthe client should always use the maximum gas cost among all contract function\ncalls - in this case ",(0,a.jsx)(t.code,{children:"300,000"}),"."]})]}),"\n",(0,a.jsx)(t.p,{children:"Finally, we make a confidential call:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:"oasis contract call INSTANCEID '{say_hello: {who: \"me\"}}' --encrypted --gas-limit 400000\n"})}),"\n",(0,a.jsx)(t.admonition,{title:"Call Format",type:"tip",children:(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.a,{href:"https://api.docs.oasis.io/oasis-sdk/oasis_contract_sdk/context/trait.Context.html",children:"Context"})," object has a special ",(0,a.jsx)(t.a,{href:"https://api.docs.oasis.io/oasis-sdk/oasis_contract_sdk/context/trait.Context.html#tymethod.call_format",children:(0,a.jsx)(t.code,{children:"call_format"})})," attribute which holds\ninformation on whether the transaction was encrypted by the client's ephemeral\nkey or not. Having access control based on this value is useful as an\nadditional safety precaution to prevent leakage of any confidential\ninformation unencrypted out of the trusted execution environment by mistake."]})}),"\n",(0,a.jsx)(t.admonition,{type:"danger",children:(0,a.jsxs)(t.p,{children:["Regardless of the encrypted transaction and confidential storage used in the\nsmart contract, any ",(0,a.jsx)(t.a,{href:"https://api.docs.oasis.io/oasis-sdk/oasis_contract_sdk/context/trait.Context.html#tymethod.emit_event",children:"emitted event"})," will be public."]})}),"\n",(0,a.jsx)(t.admonition,{title:"Example",type:"info",children:(0,a.jsxs)(t.p,{children:["You can view and download a ",(0,a.jsx)(t.a,{href:"https://github.com/oasisprotocol/oasis-sdk/tree/main/examples/contract-sdk/c10l-hello-world",children:"complete example"})," from the Oasis SDK repository."]})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>i});var o=n(96540);const a={},s=o.createContext(a);function r(e){const t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);