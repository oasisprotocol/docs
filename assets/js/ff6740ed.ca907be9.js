"use strict";(globalThis.webpackChunkdocs_oasis_io=globalThis.webpackChunkdocs_oasis_io||[]).push([[7813],{22335:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"adrs/0023-keymanager-secret-sharing","title":"ADR 0023: Secret Sharing Schemes (CHURP)","description":"Component","source":"@site/docs/adrs/0023-keymanager-secret-sharing.md","sourceDirName":"adrs","slug":"/adrs/0023-keymanager-secret-sharing","permalink":"/adrs/0023-keymanager-secret-sharing","draft":false,"unlisted":false,"editUrl":"https://github.com/oasisprotocol/adrs/edit/main/0023-keymanager-secret-sharing.md","tags":[],"version":"current","lastUpdatedAt":1754295238000,"frontMatter":{"sidebar_custom_props":{}},"sidebar":"adrs","previous":{"title":"ADR 0022: Forward-Secret Master Secrets","permalink":"/adrs/0022-keymanager-master-secrets"},"next":{"title":"ADR 0024: Runtime Off-chain Logic (ROFL)","permalink":"/adrs/0024-off-chain-runtime-logic"}}');var s=i(74848),r=i(28453);const a={sidebar_custom_props:{tags:void 0}},o="ADR 0023: Secret Sharing Schemes (CHURP)",c={},h=[{value:"Component",id:"component",level:2},{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"CHURP",id:"churp",level:2},{value:"Setup",id:"setup",level:3},{value:"Initialization",id:"initialization",level:3},{value:"Dealing",id:"dealing",level:3},{value:"Serving",id:"serving",level:3},{value:"Handoff",id:"handoff",level:3},{value:"Key derivation center",id:"key-derivation-center",level:2},{value:"Key manager applications",id:"key-manager-applications",level:2},{value:"Current situation",id:"current-situation",level:3},{value:"Workers",id:"workers",level:3},{value:"Handler trait",id:"handler-trait",level:3},{value:"Example 1",id:"example-1",level:4},{value:"Example 2",id:"example-2",level:4},{value:"Example applications",id:"example-applications",level:4},{value:"Implementation",id:"implementation",level:2},{value:"Identification",id:"identification",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Consensus transactions",id:"consensus-transactions",level:3},{value:"Churp status",id:"churp-status",level:3},{value:"Key manager worker",id:"key-manager-worker",level:3},{value:"CHURP application",id:"churp-application",level:3},{value:"Key manager client",id:"key-manager-client",level:3},{value:"Key derivation center application",id:"key-derivation-center-application",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"adr-0023-secret-sharing-schemes-churp",children:"ADR 0023: Secret Sharing Schemes (CHURP)"})}),"\n",(0,s.jsx)(n.h2,{id:"component",children:"Component"}),"\n",(0,s.jsx)(n.p,{children:"Oasis Core"}),"\n",(0,s.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"2025-07-15: Initial proposal"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,s.jsx)(n.p,{children:"Proposed"}),"\n",(0,s.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,s.jsx)(n.p,{children:"Currently, key managers derive keys from either master secrets or ephemeral\nsecrets, which are unique to the key manager runtime and shared among key\nmanager nodes. We acknowledge that this approach is not comprehensive,\nas a compromise of a single key manager enclave would reveal past secrets,\npotentially leading to the decryption of the internal state of runtimes\nusing them. However, this key derivation method is straightforward and,\nas a result, exceptionally fast."}),"\n",(0,s.jsx)(n.p,{children:"While master secret rotations and ephemeral secrets aim to rotate the secrets\nto mitigate the impact of a secret compromise, we also want to support\ndifferent types of key derivation, each offering varying levels of security.\nExamples include verifiable secret sharing schemes and dynamic-committee\nproactive secret sharing, where key managers would only hold a share\nof the secret."}),"\n",(0,s.jsx)(n.p,{children:"This proposal aims to introduce support for the CHUrn-Robust Proactive\nsecret sharing scheme (CHURP) and Key Derivation Center (KDC)."}),"\n",(0,s.jsx)(n.h2,{id:"churp",children:"CHURP"}),"\n",(0,s.jsx)(n.p,{children:"CHURP is a proactive secret sharing scheme that allows the committee of nodes,\neach holding a share of the secret, to change dynamically over time.\nThe CHURP protocol can be broadly divided into the following stages:"}),"\n",(0,s.jsx)(n.h3,{id:"setup",children:"Setup"}),"\n",(0,s.jsx)(n.p,{children:"In this stage, the key manager owner configures CHURP. All steps in this stage\ncan be performed off-chain."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The owner assigns unique, non-zero ID numbers to all nodes and associates\nthem with their public keys. A simple approach is to encode each public key\nand use its binary representation as the node\u2019s ID."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The owner selects a cipher suite based on security requirements, which\ndetermines the algebraic group used for cryptographic operations."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The owner also prepares an access control policy to specify which enclaves\nare trusted, and configures global parameters, such as how frequently key\nshares should be proactively refreshed, the minimum number of distinct shares\nrequired to reconstruct the secret, and the number of shares that can be lost\nbefore the secret becomes unrecoverable."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"initialization",children:"Initialization"}),"\n",(0,s.jsx)(n.p,{children:"Once the CHURP configuration is prepared, a new instance can be initialized."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The owner publishes the configuration in the consensus layer."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Key manager nodes that wish to participate update their configuration with\nthe CHURP instance ID generated by consensus and then restart. To avoid\nrequiring a restart, a CLI command could be added to support hot-loading\nof the updated configuration."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"After restarting, each node requests its enclave to generate a non-zero-hole\nverification matrix for the upcoming dealing phase. The node then uses\nthe checksum of this matrix to prepare an application to join the new\ncommittee and submits it to the consensus layer."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dealing",children:"Dealing"}),"\n",(0,s.jsx)(n.p,{children:"The dealing starts the first epoch with a sufficient number of nodes\nthat applied for the committee."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The first threshold plus two nodes serve as dealers; the rest are ignored.\nThe consensus will discard the verification matrices from these nodes,\nand their entropy will not be included in the secret. However, they will\nstill receive a share. The addition of two extra nodes prevents dealer\ncorruption."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The construction of the shared secret and dealing occurs off-chain through\na peer-to-peer network, following the specified enclave policy."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Each applied node (dealing):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"requests its bivariate shares (polynomials and non-zero-hole\nverification matrices) from the dealers,"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"validates received shares,"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"verifies non-zero-hole verification matrices against the consensus layer,"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"combines shares (adds polynomials and merges non-zero-hole verification\nmatrices),"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"seals the result (full share) and stores it locally in the enclave's\nconfidential storage,"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"sends a transaction containing the checksum of the merged matrix\nto the consensus layer, confirming receipt of all shares."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If the timeout or epoch expires, or if checksums do not match, the dealing\ndata in the consensus layer is cleared, and nodes must reapply for committee\nmembership."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Upon receiving confirmations from all applied nodes, the consensus layer\nannounces the new committee and begins collecting applications for the\nfirst handoff. Nodes may apply for the handoff no earlier than one epoch\nin advance."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The dealers delete the dealing data."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The committee starts serving requests."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"serving",children:"Serving"}),"\n",(0,s.jsx)(n.p,{children:"Once committee nodes receive their shares, they begin serving requests\nfor deriving key shares according to the KDC protocol, which clients\ncan use to reconstruct the derived key."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"To derive a key, a key manager client must contact at least the threshold\nnumber of committee nodes to obtain the required key shares."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The committee responds exclusively to nodes specified in the access policy."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Blame detection for corrupted key shares may be added later, though it is\ncomputational-intensive."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"handoff",children:"Handoff"}),"\n",(0,s.jsx)(n.p,{children:"Handoff transfers secret shares from the old committee to a new one.\nIt occurs periodically, as defined in the CHURP configuration."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Starts if sufficient time has elapsed since the last handoff/dealing\nand an adequate number of nodes have prepared a zero-hole verification\nmatrix and applied for the new committee."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Each applied node (share reduction):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"requests switch data points for constructing the dimension switched\npolynomial and the merged verification matrix from the current committee,"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"validates received points,"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"verifies the merged verification matrix against the consensus layer,"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"combines the points into a polynomial (reduced share)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Each applied node (proactive randomization):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"requests its bivariate shares (polynomials and zero-hole\nverification matrices) from the new committee members,"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"validates received shares,"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"verifies zero-hole verification matrices against the consensus layer,"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"applies shares to the secret polynomial and to the merged verification\nmatrix."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Each applied node (full share distribution):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"requests switch data points for constructing the dimension switched\npolynomial and the proactive verification matrix from the new committee\nmembers,"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"verifies received points,"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"combines the points into a polynomial (full share),"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"seals the result (full share) and stores it locally in the enclave's\nconfidential storage,"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"sends a transaction containing the checksum of the proactive verification\nmatrix to the consensus layer confirming that the full share was received."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If the committee hasn't changed, skip the share reduction and full node\ndistribution steps, and only execute proactive randomization."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If the timeout or epoch expires, or if checksums do not match, the handoff\ndata in the consensus layer is cleared, and nodes must reapply for committee\nmembership."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Upon receiving confirmations from all applied nodes, the consensus layer\nannounces the new committee and begins collecting applications for the\nnext handoff."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The old committee deletes obsolete full shares."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The committee starts serving requests."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-derivation-center",children:"Key derivation center"}),"\n",(0,s.jsx)(n.p,{children:"Key derivation center (KDC) is a secret sharing scheme based on\nthe verifiable secret sharing scheme (VSS) where every node possesses\nonly a share of the master secret. To derive a key from the master secret,\none needs to obtain at least threshold plus one number of key shares from\ndistinct nodes and reassemble them locally."}),"\n",(0,s.jsx)(n.h2,{id:"key-manager-applications",children:"Key manager applications"}),"\n",(0,s.jsx)(n.p,{children:"To facilitate the straightforward addition of new features to the key manager,\nwe must first generalize it to support the concurrent execution of multiple\n(independent) applications."}),"\n",(0,s.jsx)(n.p,{children:"Not all key manager runtimes are required to support all apps, and likewise,\nnot all nodes need to run all the apps. In fact, the committee nodes for each\napplication should be dynamic, allowing for the addition or removal of nodes\nbased on specific requirements."}),"\n",(0,s.jsx)(n.h3,{id:"current-situation",children:"Current situation"}),"\n",(0,s.jsx)(n.p,{children:"Currently, the key manager supports two applications: one for generating,\ndistributing, and storing master secrets, and the other for ephemeral secrets.\nHowever, these two applications are not independent, as they both share\nthe same key manager policy for secret replication and key derivation."}),"\n",(0,s.jsx)(n.p,{children:"Issues:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"In the runtime, the logic for key manager status, policy, master secrets,\nand ephemeral secrets should be decoupled."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"On the host, each application should have its own worker, e.g., a master\nsecret app should have a dedicated worker responsible for participating\nin the master secret protocol."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"workers",children:"Workers"}),"\n",(0,s.jsx)(n.p,{children:"Each key manager application should have a dedicated worker on the host node\nresponsible for communicating with the app and ensuring its consensus view\nis up-to-date. For example, a master secret worker should be responsible\nfor participating in the master secret protocol."}),"\n",(0,s.jsx)(n.h3,{id:"handler-trait",children:"Handler trait"}),"\n",(0,s.jsx)(n.p,{children:"Each application should implement the following trait, which defines\nthe enclave RPC methods exposed to the local host or remote clients.\nThese methods are registered with the dispatcher during initialization."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"/// RPC handler.\npub trait Handler {\n    /// Returns the list of RPC methods supported by this handler.\n    fn methods(&'static self) -> Vec<Method>;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Each application should adhere to the naming convention ",(0,s.jsx)(n.code,{children:"app.Method"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"example-1",children:"Example 1"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"/// Master secrets key manager application.\npub trait MasterSecrets {\n  fn generate(&self);\n  fn load(&self);\n  fn replicate(&self);\n  fn key_pair(&self);\n  fn private_key(&self);\n  fn public_key(&self);\n  fn symmetric_key(&self);\n  fn update_status(&self);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Methods:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"MasterSecrets.Generate"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"MasterSecrets.Load"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"MasterSecrets.Replicate"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"MasterSecrets.KeyPair"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"MasterSecrets.PrivateKey"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"MasterSecrets.PublicKey"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"MasterSecrets.SymmetricKey"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"MasterSecrets.UpdateStatus"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example-2",children:"Example 2"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"/// CPU change detection key manager application.\npub trait CPUChangeDetection {\n  fn encrypt(&self);\n  fn decrypt(&self);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Methods:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"CpuChange.Encrypt"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"CpuChange.Decrypt"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example-applications",children:"Example applications"}),"\n",(0,s.jsx)(n.p,{children:"Current and future applications:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Master secrets (for generation and replication master secrets)"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Ephemeral secrets (for generation and replication of ephemeral secrets)"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"CPU change (for detecting whether the CPU has changed)"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"CHURP (secret sharing scheme)"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Key derivation center (secret sharing scheme)"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.p,{children:"This section outlines the core components used to implement the CHURP protocol.\nThe implementation must support multiple secrets and remain resilient to key\nmanager restarts. To meet these goals, the implementation must satisfy\nthe following requirements:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Each group of nodes can share a unique secret."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Secrets may vary in terms of committee size, handoff intervals,\nsecurity levels, etc."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"State re-encryption should be possible with keys derived from\na new shared secret."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Key manager restarts should not lose shares or committed data."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"identification",children:"Identification"}),"\n",(0,s.jsx)(n.p,{children:"A node can be assigned a non-zero unique ID number based on its public key."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"// NodeToID assigns a unique ID to a node for use in the CHURP protocol.\nfunc NodeToID(nodeID signature.PublicKey) []byte {\n  id := nodeID\n  return id[:]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"In addition to node identifiers, each CHURP instance can also be uniquely\nidentified using the following structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// Identity uniquely identifies a CHURP instance.\ntype Identity struct {\n  // ID is a unique CHURP identifier within the key manager runtime.\n  ID uint8 `json:"id"`\n\n  // RuntimeID is the identifier of the key manager runtime.\n  RuntimeID common.Namespace `json:"runtime_id"`\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsx)(n.p,{children:"A CHURP instance can use one of several cipher suites designed for verifiable\nsecret sharing and key derivation. Each cipher suite is assigned a unique\nidentifier and must specify the following components:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"An algebraic group used for cryptographic operations."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"A hash function that maps data to elements within the group."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"A hash function that maps data to scalars in the underlying field."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Initially, we should support only one suite that uses the SHA3 hash function\nand the NIST P-384 elliptic curve. Additional suites may be added in the future."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"// NistP384Sha3_384 represents the NIST P-384 elliptic curve group with\n// the SHA3-384 hash function used to encode arbitrary-length byte strings\n// to elements of the underlying prime field or elliptic curve points.\nconst NistP384Sha3_384 uint8 = 0\n"})}),"\n",(0,s.jsx)(n.p,{children:"To protect sensitive data, each enclave running the CHURP protocol enforces\na strict access control policy. This policy defines which enclaves it is\nauthorized to communicate with during various phases of the protocol."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// PolicySGX represents an SGX access control policy used to authenticate\n// key manager enclaves during handoffs and remote client enclaves when\n// querying key shares.\ntype PolicySGX struct {\n  Identity\n\n  // Serial is the monotonically increasing policy serial number.\n  Serial uint32 `json:"serial"`\n\n  // MayShare is the vector of enclave identities from which a share can be\n  // obtained during handoffs.\n  MayShare []sgx.EnclaveIdentity `json:"may_share"`\n\n  // MayJoin is the vector of enclave identities that may form the new\n  // committee in the next handoffs.\n  MayJoin []sgx.EnclaveIdentity `json:"may_join"`\n\n  // MayQuery is the map of runtime identities to the vector of enclave\n  // identities that may query key shares.\n  MayQuery map[common.Namespace][]sgx.EnclaveIdentity `json:"may_query,omitempty"`\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"consensus-transactions",children:"Consensus transactions"}),"\n",(0,s.jsx)(n.p,{children:"The following method names define the CHURP-related transactions to be added\nto the consensus layer:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// MethodCreate is the method name for creating a new CHURP instance.\nvar MethodCreate = transaction.NewMethodName(ModuleName, "Create", CreateRequest{})\n\n// CreateRequest contains the initial configuration.\ntype CreateRequest struct {\n  Identity\n\n  // SuiteID is the identifier of a cipher suite used for verifiable secret\n  // sharing and key derivation.\n  SuiteID uint8 `json:"suite_id,omitempty"`\n\n  // Threshold is the minimum number of distinct shares required\n  // to reconstruct a key.\n  Threshold uint8 `json:"threshold,omitempty"`\n\n  // ExtraShares represents the minimum number of shares that can be lost\n  // to render the secret unrecoverable.\n  ExtraShares uint8 `json:"extra_shares,omitempty"`\n\n  // HandoffInterval is the time interval in epochs between handoffs.\n  //\n  // A zero value disables handoffs.\n  HandoffInterval beacon.EpochTime `json:"handoff_interval,omitempty"`\n\n  // Policy is a signed SGX access control policy.\n  Policy SignedPolicySGX `json:"policy,omitempty"`\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// MethodUpdate is the method name for CHURP updates.\nvar MethodUpdate = transaction.NewMethodName(ModuleName, "Update", UpdateRequest{})\n\n// UpdateRequest contains the updated configuration.\ntype UpdateRequest struct {\n  Identity\n\n  // ExtraShares represents the minimum number of shares that can be lost\n  // to render the secret unrecoverable.\n  ExtraShares *uint8 `json:"extra_shares,omitempty"`\n\n  // HandoffInterval is the time interval in epochs between handoffs.\n  //\n  // Zero value disables handoffs.\n  HandoffInterval *beacon.EpochTime `json:"handoff_interval,omitempty"`\n\n  // Policy is a signed SGX access control policy.\n  Policy *SignedPolicySGX `json:"policy,omitempty"`\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// MethodApply is the method name for a node submitting an application\n// to form a new committee.\nvar MethodApply = transaction.NewMethodName(ModuleName, "Apply", ApplicationRequest{})\n\n// ApplicationRequest contains node\'s application to form a new committee.\ntype ApplicationRequest struct {\n  // Identity of the CHRUP scheme.\n  Identity\n\n  // Epoch is the epoch of the handoff for which the node would like\n  // to apply.\n  Epoch beacon.EpochTime `json:"epoch"`\n\n  // Checksum is the hash of the verification matrix.\n  Checksum hash.Hash `json:"checksum"`\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// MethodConfirm is the method name for a node confirming completion\n// of a handoff.\nvar MethodConfirm = transaction.NewMethodName(ModuleName, "Confirm", ConfirmationRequest{})\n\n// ConfirmationRequest confirms that the node successfully completed\n// the handoff.\ntype ConfirmationRequest struct {\n  Identity\n\n  // Epoch is the epoch of the handoff for which the node reconstructed\n  // the share.\n  Epoch beacon.EpochTime `json:"epoch"`\n\n  // Checksum is the hash of the verification matrix.\n  Checksum hash.Hash `json:"checksum"`\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"churp-status",children:"Churp status"}),"\n",(0,s.jsx)(n.p,{children:"The CHURP status provides a comprehensive overview of the selected instance.\nIt includes information such as how frequently handoffs occur, when the next\nhandoff is scheduled, which nodes have submitted applications for the upcoming\nhandoff, and which nodes form the current committee."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'\n// Status represents the current state of a CHURP instance.\ntype Status struct {\n  Identity\n\n  // SuiteID is the identifier of a cipher suite used for verifiable secret\n  // sharing and key derivation.\n  SuiteID uint8 `json:"suite_id"`\n\n  // Threshold represents the degree of the secret-sharing polynomial.\n  //\n  // In a (t,n) secret-sharing scheme, where t represents the threshold,\n  // any combination of t+1 or more shares can reconstruct the secret,\n  // while losing n-t or fewer shares still allows the secret to be\n  // recovered.\n  Threshold uint8 `json:"threshold"`\n\n  // ExtraShares represents the minimum number of shares that can be lost\n  // to render the secret unrecoverable.\n  //\n  // If t and e represent the threshold and extra shares, respectively,\n  // then the minimum size of the committee is t+e+1.\n  ExtraShares uint8 `json:"extra_shares"`\n\n  // HandoffInterval is the time interval in epochs between handoffs.\n  //\n  // A zero value disables handoffs.\n  HandoffInterval beacon.EpochTime `json:"handoff_interval"`\n\n  // Policy is a signed SGX access control policy.\n  Policy SignedPolicySGX `json:"policy"`\n\n  // Handoff is the epoch of the last successfully completed handoff.\n  //\n  // The zero value indicates that no handoffs have been completed so far.\n  // Note that the first handoff is special and is called the dealer phase,\n  // in which nodes do not reshare or randomize shares but instead construct\n  // the secret and shares.\n  Handoff beacon.EpochTime `json:"handoff"`\n\n  // The hash of the verification matrix from the last successfully completed\n  // handoff.\n  Checksum *hash.Hash `json:"checksum,omitempty"`\n\n  // Committee is a vector of nodes holding a share of the secret\n  // in the active handoff.\n  //\n  // A client needs to obtain more than a threshold number of key shares\n  // from the nodes in this vector to construct the key.\n  Committee []signature.PublicKey `json:"committee,omitempty"`\n\n  // NextHandoff defines the epoch in which the next handoff will occur.\n  //\n  // If an insufficient number of applications is received, the next handoff\n  // will be delayed by one epoch.\n  NextHandoff beacon.EpochTime `json:"next_handoff"`\n\n  // NextChecksum is the hash of the verification matrix from the current\n  // handoff.\n  //\n  // The first candidate to confirm share reconstruction is the source\n  // of truth for the checksum. All other candidates need to confirm\n  // with the same checksum; otherwise, the applications will be annulled,\n  // and the nodes will need to apply for the new committee again.\n  NextChecksum *hash.Hash `json:"next_checksum,omitempty"`\n\n  // Applications is a map of nodes that wish to form the new committee.\n  //\n  // Candidates are expected to generate a random bivariate polynomial,\n  // construct a verification matrix, compute its checksum, and submit\n  // an application one epoch in advance of the next scheduled handoff.\n  // Subsequently, upon the arrival of the handoff epoch, nodes must execute\n  // the handoff protocol and confirm the reconstruction of its share.\n  Applications map[signature.PublicKey]Application `json:"applications,omitempty"`\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"key-manager-worker",children:"Key manager worker"}),"\n",(0,s.jsx)(n.p,{children:"Enabling CHURP on a key manager node requires explicitly specifying\nthe CHURP instances it should join."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// Config is the keymanager worker configuration structure.\ntype Config struct {\n  // ... existing fields omitted ...\n\n  // Churp holds configuration details for the CHURP extension.\n  Churp ChurpConfig `yaml:"churp,omitempty"`\n}\n\n// ChurpConfig holds configuration details for the CHURP extension.\ntype ChurpConfig struct {\n  // Schemes is a list of CHURP scheme configurations.\n  Schemes []ChurpSchemeConfig `yaml:"schemes,omitempty"`\n}\n\n// ChurpSchemeConfig holds configuration details for a CHURP scheme.\ntype ChurpSchemeConfig struct {\n  // ID is the unique identifier of the CHURP scheme.\n  ID uint8 `yaml:"id,omitempty"`\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"churp-application",children:"CHURP application"}),"\n",(0,s.jsx)(n.p,{children:"The application should be capable of running multiple CHURP instances,\nwith each instance implementing the following trait:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"/// Interface for handling a CHURP instance.\npub(crate) trait Handler: Send + Sync {\n    /// Returns the verification matrix of the shared secret bivariate\n    /// polynomial from the last successfully completed handoff.\n    ///\n    /// The verification matrix is a matrix of dimensions t_n x t_m, where\n    /// t_n = threshold and t_m = 2 * threshold + 1. It contains encrypted\n    /// coefficients of the secret bivariate polynomial whose zero coefficient\n    /// represents the shared secret.\n    ///\n    /// Verification matrix:\n    /// ```text\n    ///     M = [b_{i,j} * G]\n    /// ```\n    /// Bivariate polynomial:\n    /// ```text\n    ///     B(x,y) = \\sum_{i=0}^{t_n} \\sum_{j=0}^{t_m} b_{i,j} x^i y^j\n    /// ```\n    /// Shared secret:\n    /// ```text\n    ///     Secret = B(0, 0)\n    /// ```\n    ///\n    /// This matrix is used to verify switch points derived from the bivariate\n    /// polynomial share in handoffs.\n    ///\n    /// NOTE: This method can be called over an insecure channel, as the matrix\n    /// does not contain any sensitive information. However, the checksum\n    /// of the matrix should always be verified against the consensus layer.\n    fn verification_matrix(&self, req: &QueryRequest) -> Result<Vec<u8>>;\n\n    /// Returns switch point for share reduction for the calling node.\n    ///\n    /// The point is evaluation of the shared secret bivariate polynomial\n    /// at the given x (me) and y value (node ID).\n    ///\n    /// Switch point:\n    /// ```text\n    ///     Point = B(me, node_id)\n    /// ```\n    /// Bivariate polynomial:\n    /// ```text\n    ///     B(x,y) = \\sum_{i=0}^{t_n} \\sum_{j=0}^{t_m} b_{i,j} x^i y^j\n    /// ```\n    ///\n    /// WARNING: This method must be called over a secure channel as the point\n    /// needs to be kept secret and generated only for authorized nodes.\n    fn share_reduction_switch_point(&self, ctx: &RpcContext, req: &QueryRequest)\n        -> Result<Vec<u8>>;\n\n    /// Returns switch point for full share distribution for the calling node.\n    ///\n    /// The point is evaluation of the proactivized shared secret bivariate\n    /// polynomial at the given x (node ID) and y value (me).\n    ///\n    /// Switch point:\n    /// ```text\n    ///     Point = B(node_id, me) + \\sum Q_i(node_id, me)\n    /// ```\n    /// Bivariate polynomial:\n    /// ```text\n    ///     B(x,y) = \\sum_{i=0}^{t_n} \\sum_{j=0}^{t_m} b_{i,j} x^i y^j\n    /// ```\n    /// Proactive bivariate polynomial:\n    /// ```text\n    ///     Q_i(x,y) = \\sum_{i=0}^{t_n} \\sum_{j=0}^{t_m} b_{i,j} x^i y^j\n    /// ```\n    ///\n    /// WARNING: This method must be called over a secure channel as the point\n    /// needs to be kept secret and generated only for authorized nodes.\n    fn share_distribution_switch_point(\n        &self,\n        ctx: &RpcContext,\n        req: &QueryRequest,\n    ) -> Result<Vec<u8>>;\n\n    /// Returns proactive bivariate polynomial share for the calling node.\n    ///\n    /// A bivariate share is a partial evaluation of a randomly selected\n    /// bivariate polynomial at a specified x or y value (node ID). Each node\n    /// interested in joining the new committee selects a bivariate polynomial\n    /// before the next handoff and commits to it by submitting the checksum\n    /// of the corresponding verification matrix to the consensus layer.\n    /// The latter can be used to verify the received bivariate shares.\n    ///\n    /// Bivariate polynomial share:\n    /// ```text\n    ///     S_i(y) = Q_i(node_id, y) (dealing phase or unchanged committee)\n    ///     S_i(x) = Q_i(x, node_id) (committee changes)\n    /// ```\n    /// Proactive bivariate polynomial:\n    /// ```text\n    ///     Q_i(x,y) = \\sum_{i=0}^{t_n} \\sum_{j=0}^{t_m} b_{i,j} x^i y^j\n    /// ```\n    ///\n    /// WARNING: This method must be called over a secure channel as\n    /// the polynomial needs to be kept secret and generated only\n    /// for authorized nodes.\n    fn bivariate_share(\n        &self,\n        ctx: &RpcContext,\n        req: &QueryRequest,\n    ) -> Result<EncodedVerifiableSecretShare>;\n\n    /// Returns the key share for the given key ID generated by the key\n    /// derivation center.\n    ///\n    /// Key share:\n    /// ```text\n    ///     KS_i = s_i * H(key_id)\n    /// ```\n    ///\n    /// WARNING: This method must be called over a secure channel as the key\n    /// share needs to be kept secret and generated only for authorized nodes.\n    fn sgx_policy_key_share(\n        &self,\n        ctx: &RpcContext,\n        req: &KeyShareRequest,\n    ) -> Result<EncodedEncryptedPoint>;\n\n    /// Prepare CHURP for participation in the given handoff of the protocol.\n    ///\n    /// Initialization randomly selects a bivariate polynomial for the given\n    /// handoff, computes the corresponding verification matrix and its\n    /// checksum, and signs the latter.\n    ///\n    /// Bivariate polynomial:\n    ///     B(x,y) = \\sum_{i=0}^{t_n} \\sum_{j=0}^{t_m} b_{i,j} x^i y^j\n    ///\n    /// Verification matrix:\n    ///     M = [b_{i,j} * G]\n    ///\n    /// Checksum:\n    ///     H = KMAC256(M, runtime ID, handoff)\n    ///\n    /// The bivariate polynomial is zero-hole in all handoffs expect in the\n    /// first one (dealing phase).\n    ///\n    /// This method must be called locally.\n    fn apply(&self, req: &HandoffRequest) -> Result<SignedApplicationRequest>;\n\n    /// Tries to fetch switch points for share reduction from the given nodes.\n    ///\n    /// Switch points should be obtained from (at least) t distinct nodes\n    /// belonging to the old committee, verified against verification matrix\n    /// whose checksum was published in the consensus layer, merged into\n    /// a reduced share using Lagrange interpolation and proactivized with\n    /// bivariate shares.\n    ///\n    /// Switch point:\n    /// ```text\n    ///     P_i = B(node_i, me)\n    ///```\n    /// Reduced share:\n    /// ```text\n    ///     RS(x) = B(x, me)\n    /// ````\n    /// Proactive reduced share:\n    /// ```text\n    ///     QR(x) = RS(x) + \\sum Q_i(x, me)\n    /// ````\n    fn share_reduction(&self, req: &FetchRequest) -> Result<FetchResponse>;\n\n    /// Tries to fetch switch data points for full share distribution from\n    /// the given nodes.\n    ///\n    /// Switch points should be obtained from (at least) 2t distinct nodes\n    /// belonging to the new committee, verified against the sum of the\n    /// verification matrix and the verification matrices of proactive\n    /// bivariate shares, whose checksums were published in the consensus\n    /// layer, and merged into a full share using Lagrange interpolation.\n    ///\n    /// Switch point:\n    /// ```text\n    ///     P_i = B(me, node_i) + \\sum Q_i(me, node_i)\n    ///```\n    /// Full share:\n    /// ```text\n    ///     FS(x) = B(me, y) + \\sum Q_i(me, y) = B'(me, y)\n    /// ````\n    fn share_distribution(&self, req: &FetchRequest) -> Result<FetchResponse>;\n\n    /// Tries to fetch proactive bivariate shares from the given nodes.\n    ///\n    /// Bivariate shares should be fetched from all candidates for the new\n    /// committee, including our own, verified against verification matrices\n    /// whose checksums were published in the consensus layer, and summed\n    /// into a bivariate polynomial.\n    ///\n    /// Bivariate polynomial share:\n    /// ```text\n    ///     S_i(y) = Q_i(me, y) (dealing phase or unchanged committee)\n    ///     S_i(x) = Q_i(x, me) (committee changes)\n    /// ```\n    fn proactivization(&self, req: &FetchRequest) -> Result<FetchResponse>;\n\n    /// Returns a signed confirmation request containing the checksum\n    /// of the merged verification matrix.\n    fn confirmation(&self, req: &HandoffRequest) -> Result<SignedConfirmationRequest>;\n\n    /// Finalizes the specified scheme by cleaning up obsolete dealers,\n    /// handoffs, and shareholders. If the handoff was just completed,\n    /// the shareholder is made available, and its share is persisted\n    /// to the local storage.\n    fn finalize(&self, req: &HandoffRequest) -> Result<()>;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Methods:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Churp.Apply"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Churp.ShareReduction"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Churp.ShareDistribution"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Churp.Proactivization"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Churp.Confirm"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Churp.Finalize"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Churp.VerificationMatrix"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Churp.ShareReductionPoint"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Churp.ShareDistributionPoint"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Churp.BivariateShare"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Churp.SGXPolicyKeyShare"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-manager-client",children:"Key manager client"}),"\n",(0,s.jsx)(n.p,{children:"The key manager client should be extended to support CHURP functionality."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"\n/// Key manager client interface.\n#[async_trait]\npub trait KeyManagerClient: Send + Sync {\n    /// ... existing fields omitted ...\n\n    /// Returns the verification matrix for the given handoff.\n    async fn churp_verification_matrix(\n        &self,\n        churp_id: u8,\n        epoch: EpochTime,\n        nodes: Vec<PublicKey>,\n    ) -> Result<Vec<u8>, KeyManagerError>;\n\n    /// Returns a switch point for the share reduction phase\n    /// of the given handoff.\n    async fn churp_share_reduction_point(\n        &self,\n        churp_id: u8,\n        epoch: EpochTime,\n        node_id: PublicKey,\n        nodes: Vec<PublicKey>,\n    ) -> Result<Vec<u8>, KeyManagerError>;\n\n    /// Returns a switch point for the share distribution phase\n    /// of the given handoff.\n    async fn churp_share_distribution_point(\n        &self,\n        churp_id: u8,\n        epoch: EpochTime,\n        node_id: PublicKey,\n        nodes: Vec<PublicKey>,\n    ) -> Result<Vec<u8>, KeyManagerError>;\n\n    /// Returns a bivariate share for the given handoff.\n    async fn churp_bivariate_share(\n        &self,\n        churp_id: u8,\n        epoch: EpochTime,\n        node_id: PublicKey,\n        nodes: Vec<PublicKey>,\n    ) -> Result<EncodedVerifiableSecretShare, KeyManagerError>;\n\n    /// Returns state key.\n    async fn churp_state_key(\n        &self,\n        churp_id: u8,\n        key_id: KeyPairId,\n    ) -> Result<StateKey, KeyManagerError>;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"key-derivation-center-application",children:"Key derivation center application"}),"\n",(0,s.jsx)(n.p,{children:"The key derivation center must implement the following traits to support share\ngeneration and key recovery."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"/// A trait for shareholders capable of deriving key shares.\npub trait KeySharer<G: Group> {\n    /// Derives a key share based on the given key ID and domain separation tag.\n    fn make_key_share<H: GroupDigest<Output = G>>(\n        &self,\n        key_id: &[u8],\n        dst: &[u8],\n    ) -> Result<EncryptedPoint<G>>;\n}\n\n/// A trait for recovering a secret key from key shares.\npub trait KeyRecoverer {\n    /// Returns the minimum number of key shares required to recover\n    /// the secret key.\n    fn min_shares(&self) -> usize;\n\n    /// Recovers the secret key from the provided key shares.\n    fn recover_key<G>(&self, shares: &[EncryptedPoint<G>]) -> Result<G>\n    where\n        G: Group + Zeroize;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,s.jsx)(n.p,{children:"CHURP:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"High security, as the master secret is shared among key manager nodes."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Supports proactive randomization (share refresh)."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Dynamic committees."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"KDC:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"High security, as the master secret is shared among key manager nodes."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Supports proactive randomization (share refresh)."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,s.jsx)(n.p,{children:"CHURP:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Handoffs are computationally intensive."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"KDC:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The number of key manager nodes that share a master secret is fixed and\ncannot be changed once shares are generated. Consequently, if too many\nnodes are destroyed, the secret cannot be recovered."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Support for replicating a share to a specific node is needed."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"neutral",children:"Neutral"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Issuing derived key shares with CHURP should be slightly slower compared\nto KDC."}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);